<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>V8 Project: &lt;tt&gt;base/numerics&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">V8 Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_V8SourceCode_src_base_numerics_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><code>base/numerics</code> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1">Common patterns and use-cases</a><ul><li class="level2"><a href="#autotoc_md2">Performing checked arithmetic type conversions</a></li>
<li class="level2"><a href="#autotoc_md3">Performing saturated (clamped) arithmetic type conversions</a></li>
<li class="level2"><a href="#autotoc_md4">Enforcing arithmetic type conversions at compile-time</a></li>
<li class="level2"><a href="#autotoc_md5">Comparing values between arbitrary arithmetic types</a></li>
<li class="level2"><a href="#autotoc_md6">Calculating a buffer size (checked arithmetic)</a></li>
<li class="level2"><a href="#autotoc_md7">Calculating clamped coordinates (non-sticky saturating arithmetic)</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md8">Conversion functions and StrictNumeric&lt;&gt; in safe_conversions.h</a><ul><li class="level2"><a href="#autotoc_md9">Safe casting templates</a></li>
<li class="level2"><a href="#autotoc_md10">Other helper and conversion functions</a></li>
<li class="level2"><a href="#autotoc_md11">StrictNumeric&lt;&gt;</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md12">CheckedNumeric&lt;&gt; in checked_math.h</a><ul><li class="level2"><a href="#autotoc_md13">Example</a></li>
<li class="level2"><a href="#autotoc_md14">Members</a></li>
<li class="level2"><a href="#autotoc_md15">Non-member helper functions</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md16">ClampedNumeric&lt;&gt; in clamped_math.h</a><ul><li class="level2"><a href="#autotoc_md17">Members</a></li>
<li class="level2"><a href="#autotoc_md18">Non-member helper functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This directory contains a dependency-free, header-only library of templates providing well-defined semantics for safely and performantly handling a variety of numeric operations, including most common arithmetic operations and conversions.</p>
<p>The public API is broken out into the following header files:</p>
<ul>
<li><code>checked_math.h</code> contains the <code>CheckedNumeric</code> template class and helper functions for performing arithmetic and conversion operations that detect errors and boundary conditions (e.g. overflow, truncation, etc.).</li>
<li><code>clamped_math.h</code> contains the <code>ClampedNumeric</code> template class and helper functions for performing fast, clamped (i.e. <a href="#notsticky">non-sticky</a> saturating) arithmetic operations and conversions.</li>
<li><code>safe_conversions.h</code> contains the <code>StrictNumeric</code> template class and a collection of custom casting templates and helper functions for safely converting between a range of numeric types.</li>
<li><code>safe_math.h</code> includes all of the previously mentioned headers.</li>
</ul>
<p>*** aside <b>Note:</b> The <code>Numeric</code> template types implicitly convert from C numeric types and <code>Numeric</code> templates that are convertible to an underlying C numeric type. The conversion priority for <code>Numeric</code> type coercions is:</p>
<ul>
<li><code>StrictNumeric</code> coerces to <code>ClampedNumeric</code> and <code>CheckedNumeric</code></li>
<li><code>ClampedNumeric</code> coerces to <code>CheckedNumeric</code> <hr  />
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Common patterns and use-cases</h1>
<p>The following covers the preferred style for the most common uses of this library. Please don't cargo-cult from anywhere else. ðŸ˜‰</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Performing checked arithmetic type conversions</h2>
<p>The <code>checked_cast</code> template converts between arbitrary arithmetic types, and is used for cases where a conversion failure should result in program termination:</p>
<div class="fragment"><div class="line"><span class="comment">// Crash if signed_value is out of range for buff_size.</span></div>
<div class="line"><span class="keywordtype">size_t</span> buff_size = checked_cast&lt;size_t&gt;(signed_value);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Performing saturated (clamped) arithmetic type conversions</h2>
<p>The <code>saturated_cast</code> template converts between arbitrary arithmetic types, and is used in cases where an out-of-bounds source value should be saturated to the corresponding maximum or minimum of the destination type:</p>
<div class="fragment"><div class="line"><span class="comment">// Cast to a smaller type, saturating as needed.</span></div>
<div class="line">int8_t eight_bit_value = saturated_cast&lt;int8_t&gt;(int_value);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Convert from float with saturation to INT_MAX, INT_MIN, or 0 for NaN.</span></div>
<div class="line"><span class="keywordtype">int</span> int_value = saturated_cast&lt;int&gt;(floating_point_value);</div>
</div><!-- fragment --><p><code>ClampCeil</code>, <code>ClampFloor</code>, and <code>ClampRound</code> provide similar functionality to the versions in <code>std::</code>, but saturate and return an integral type. An optional template parameter specifies the desired destination type (<code>int</code> if unspecified). These should be used for most floating-to-integral conversions.</p>
<div class="fragment"><div class="line"><span class="comment">// Basically saturated_cast&lt;int&gt;(std::round(floating_point_value)).</span></div>
<div class="line"><span class="keywordtype">int</span> int_value = ClampRound(floating_point_value);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A destination type can be explicitly specified.</span></div>
<div class="line">uint8_t byte_value = ClampFloor&lt;uint8_t&gt;(floating_point_value);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Enforcing arithmetic type conversions at compile-time</h2>
<p>The <code>strict_cast</code> emits code that is identical to <code>static_cast</code>. However, provides static checks that will cause a compilation failure if the destination type cannot represent the full range of the source type:</p>
<div class="fragment"><div class="line"><span class="comment">// Throw a compiler error if byte_value is changed to an out-of-range-type.</span></div>
<div class="line"><span class="keywordtype">int</span> int_value = strict_cast&lt;int&gt;(byte_value);</div>
</div><!-- fragment --><p>You can also enforce these compile-time restrictions on function parameters by using the <code>StrictNumeric</code> template:</p>
<div class="fragment"><div class="line"><span class="comment">// Throw a compiler error if the size argument cannot be represented by a</span></div>
<div class="line"><span class="comment">// size_t (e.g. passing an int will fail to compile).</span></div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespacev8_1_1internal_1_1baseline_1_1anonymous__namespace_02baseline-compiler_8cc_03.html#a934de571162bc47e7cf9f2be65dd3a3e">AllocateBuffer</a>(<span class="keywordtype">void</span>** buffer, StrictNumeric&lt;size_t&gt; <a class="code" href="flag-definitions_8h.html#a3df0b28b666e942ffb9d7d04acdb9715">size</a>);</div>
<div class="ttc" id="aflag-definitions_8h_html_a3df0b28b666e942ffb9d7d04acdb9715"><div class="ttname"><a href="flag-definitions_8h.html#a3df0b28b666e942ffb9d7d04acdb9715">size</a></div><div class="ttdeci">too high values may cause the compiler to set high thresholds for inlining to as much as possible avoid inlined allocation of objects that cannot escape trace load stores from virtual maglev objects use TurboFan fast string builder analyze liveness of environment slots and zap dead values trace TurboFan load elimination emit data about basic block usage in builtins to this enable builtin reordering when run mksnapshot flag for emit warnings when applying builtin profile data verify register allocation in TurboFan randomly schedule instructions to stress dependency tracking enable store store elimination in TurboFan rewrite far to near simulate GC compiler thread race related to allow float parameters to be passed in simulator mode JS Wasm Run additional turbo_optimize_inlined_js_wasm_wrappers enables Turboshaft s StaticAssert and CheckTurboshaftTypeOf operations Wasm code into JS functions via the JS to Wasm wrappers are still inlined in TurboFan For controlling whether to at see turbo inline js wasm calls enable Turboshaft s loop unrolling enable an additional Turboshaft phase that performs optimizations based on type information enable Turbolev features that we want to ship in the not too far future trace individual Turboshaft reduction steps trace intermediate Turboshaft reduction steps trace Turboshaft s if else to switch reducer invocation count threshold for early optimization Enables optimizations which favor memory size over execution speed Enables sampling allocation profiler with X as a sample interval min size of a semi the new space consists of two semi spaces max size of the preconfigured old space size(in Mbytes)&quot;)     DEFINE_INT(random_gc_interval</div></div>
<div class="ttc" id="anamespacev8_1_1internal_1_1baseline_1_1anonymous__namespace_02baseline-compiler_8cc_03_html_a934de571162bc47e7cf9f2be65dd3a3e"><div class="ttname"><a href="namespacev8_1_1internal_1_1baseline_1_1anonymous__namespace_02baseline-compiler_8cc_03.html#a934de571162bc47e7cf9f2be65dd3a3e">v8::internal::baseline::anonymous_namespace{baseline-compiler.cc}::AllocateBuffer</a></div><div class="ttdeci">std::unique_ptr&lt; AssemblerBuffer &gt; AllocateBuffer(DirectHandle&lt; BytecodeArray &gt; bytecodes)</div><div class="ttdef"><b>Definition:</b> <a href="baseline-compiler_8cc_source.html#l00269">baseline-compiler.cc:269</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Comparing values between arbitrary arithmetic types</h2>
<p>Both the <code>StrictNumeric</code> and <code>ClampedNumeric</code> types provide well defined comparisons between arbitrary arithmetic types. This allows you to perform comparisons that are not legal or would trigger compiler warnings or errors under the normal arithmetic promotion rules:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> foo(<span class="keywordtype">unsigned</span> <a class="code" href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">value</a>, <span class="keywordtype">int</span> upper_bound) {</div>
<div class="line">  <span class="comment">// Converting to StrictNumeric allows this comparison to work correctly.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespacev8_1_1base_1_1internal.html#a37c4734e88ec34f651efc5c3ac0d4a60">MakeStrictNum</a>(<a class="code" href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">value</a>) &gt;= upper_bound)</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="ttc" id="anamespacev8_1_1base_1_1internal_html_a37c4734e88ec34f651efc5c3ac0d4a60"><div class="ttname"><a href="namespacev8_1_1base_1_1internal.html#a37c4734e88ec34f651efc5c3ac0d4a60">v8::base::internal::MakeStrictNum</a></div><div class="ttdeci">constexpr StrictNumeric&lt; UnderlyingType&lt; T &gt; &gt; MakeStrictNum(const T value)</div><div class="ttdef"><b>Definition:</b> <a href="safe__conversions_8h_source.html#l00310">safe_conversions.h:310</a></div></div>
<div class="ttc" id="anamespacev8_1_1internal_html_ac1a33b5fd9af1653d346746cdb5c1ac0"><div class="ttname"><a href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">v8::internal::value</a></div><div class="ttdeci">return value</div><div class="ttdef"><b>Definition:</b> <a href="map-inl_8h_source.html#l00912">map-inl.h:912</a></div></div>
</div><!-- fragment --><p>*** note <b>Warning:</b> Do not perform manual conversions using the comparison operators. Instead, use the cast templates described in the previous sections, or the constexpr template functions <code>IsValueInRangeForNumericType</code> and <code>IsTypeInRangeForNumericType</code>, as these templates properly handle the full range of corner cases and employ various optimizations. </p><hr  />
<h2><a class="anchor" id="autotoc_md6"></a>
Calculating a buffer size (checked arithmetic)</h2>
<p>When making exact calculationsâ€”such as for buffer lengthsâ€”it's often necessary to know when those calculations trigger an overflow, undefined behavior, or other boundary conditions. The <code>CheckedNumeric</code> template does this by storing a bit determining whether or not some arithmetic operation has occurred that would put the variable in an "invalid" state. Attempting to extract the value from a variable in an invalid state will trigger a check/trap condition, that by default will result in process termination.</p>
<p>Here's an example of a buffer calculation using a <code>CheckedNumeric</code> type (note: the AssignIfValid method will trigger a compile error if the result is ignored).</p>
<div class="fragment"><div class="line"><span class="comment">// Calculate the buffer size and detect if an overflow occurs.</span></div>
<div class="line"><span class="keywordtype">size_t</span> <a class="code" href="flag-definitions_8h.html#a3df0b28b666e942ffb9d7d04acdb9715">size</a>;</div>
<div class="line"><span class="keywordflow">if</span> (!CheckAdd(kHeaderSize, CheckMul(count, kItemSize)).AssignIfValid(&amp;<a class="code" href="flag-definitions_8h.html#a3df0b28b666e942ffb9d7d04acdb9715">size</a>)) {</div>
<div class="line">  <span class="comment">// Handle an overflow error...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Calculating clamped coordinates (non-sticky saturating arithmetic)</h2>
<p>Certain classes of calculationsâ€”such as coordinate calculationsâ€”require well-defined semantics that always produce a valid result on boundary conditions. The <code>ClampedNumeric</code> template addresses this by providing performant, non-sticky saturating arithmetic operations.</p>
<p>Here's an example of using a <code>ClampedNumeric</code> to calculate an operation insetting a rectangle.</p>
<div class="fragment"><div class="line"><span class="comment">// Use clamped arithmetic since inset calculations might overflow.</span></div>
<div class="line"><span class="keywordtype">void</span> Rect::Inset(<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> top, <span class="keywordtype">int</span> right, <span class="keywordtype">int</span> bottom) {</div>
<div class="line">  origin_ += Vector2d(left, top);</div>
<div class="line">  set_width(ClampSub(width(), ClampAdd(left, right)));</div>
<div class="line">  set_height(ClampSub(height(), ClampAdd(top, bottom)));</div>
<div class="line">}</div>
</div><!-- fragment --><p>*** note <a class="anchor" id="notsticky"></a> The <code>ClampedNumeric</code> type is not "sticky", which means the saturation is not retained across individual operations. As such, one arithmetic operation may result in a saturated value, while the next operation may then "desaturate" the value. Here's an example:</p>
<div class="fragment"><div class="line">ClampedNumeric&lt;int&gt; <a class="code" href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">value</a> = INT_MAX;</div>
<div class="line">++<a class="code" href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">value</a>;  <span class="comment">// value is still INT_MAX, due to saturation.</span></div>
<div class="line">--<a class="code" href="namespacev8_1_1internal.html#ac1a33b5fd9af1653d346746cdb5c1ac0">value</a>;  <span class="comment">// value is now (INT_MAX - 1), because saturation is not sticky.</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md8"></a>
Conversion functions and StrictNumeric&lt;&gt; in safe_conversions.h</h1>
<p>This header includes a collection of helper <code>constexpr</code> templates for safely performing a range of conversions, assignments, and tests.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Safe casting templates</h2>
<ul>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#a9158b5be0bb0e80e75170b5dfc5618aa">as_signed()</a></code> - Returns the supplied integral value as a signed type of the same width.</li>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#ac03df80e2f10b02403fef35275e5269f">as_unsigned()</a></code> - Returns the supplied integral value as an unsigned type of the same width.</li>
<li><code>checked_cast&lt;&gt;()</code> - Analogous to <code>static_cast&lt;&gt;</code> for numeric types, except that by default it will trigger a crash on an out-of-bounds conversion (e.g. overflow, underflow, NaN to integral) or a compile error if the conversion error can be detected at compile time. The crash handler can be overridden to perform a behavior other than crashing.</li>
<li><code>saturated_cast&lt;&gt;()</code> - Analogous to <code>static_cast</code> for numeric types, except that it returns a saturated result when the specified numeric conversion would otherwise overflow or underflow. An NaN source returns 0 by default, but can be overridden to return a different result.</li>
<li><code>strict_cast&lt;&gt;()</code> - Analogous to <code>static_cast</code> for numeric types, except this causes a compile failure if the destination type is not large enough to contain any value in the source type. It performs no runtime checking and thus introduces no runtime overhead.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Other helper and conversion functions</h2>
<ul>
<li><code>ClampCeil&lt;&gt;()</code> - A convenience function that computes the ceil of its floating- point arg, then saturates to the destination type (template parameter, defaults to <code>int</code>).</li>
<li><code>ClampFloor&lt;&gt;()</code> - A convenience function that computes the floor of its floating-point arg, then saturates to the destination type (template parameter, defaults to <code>int</code>).</li>
<li><code>IsTypeInRangeForNumericType&lt;&gt;()</code> - A convenience function that evaluates entirely at compile-time and returns true if the destination type (first template parameter) can represent the full range of the source type (second template parameter).</li>
<li><code>IsValueInRangeForNumericType&lt;&gt;()</code> - A convenience function that returns true if the type supplied as the template parameter can represent the value passed as an argument to the function.</li>
<li><code>IsValueNegative()</code> - A convenience function that will accept any arithmetic type as an argument and will return whether the value is less than zero. Unsigned types always return false.</li>
<li><code>ClampRound&lt;&gt;()</code> - A convenience function that rounds its floating-point arg, then saturates to the destination type (template parameter, defaults to <code>int</code>).</li>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#a72b52aeae4b2115ab648f6fd17a7c238">SafeUnsignedAbs()</a></code> - Returns the absolute value of the supplied integer parameter as an unsigned result (thus avoiding an overflow if the value is the signed, two's complement minimum).</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
StrictNumeric&lt;&gt;</h2>
<p><code>StrictNumeric&lt;&gt;</code> is a wrapper type that performs assignments and copies via the <code>strict_cast</code> template, and can perform valid arithmetic comparisons across any range of arithmetic types. <code>StrictNumeric</code> is the return type for values extracted from a <code>CheckedNumeric</code> class instance. The raw numeric value is extracted via <code>static_cast</code> to the underlying type or any type with sufficient range to represent the underlying type.</p>
<ul>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#a37c4734e88ec34f651efc5c3ac0d4a60">MakeStrictNum()</a></code> - Creates a new <code>StrictNumeric</code> from the underlying type of the supplied arithmetic or StrictNumeric type.</li>
<li><code>SizeT</code> - Alias for <code>StrictNumeric&lt;size_t&gt;</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
CheckedNumeric&lt;&gt; in checked_math.h</h1>
<p><code>CheckedNumeric&lt;&gt;</code> implements all the logic and operators for detecting integer boundary conditions such as overflow, underflow, and invalid conversions. The <code>CheckedNumeric</code> type implicitly converts from floating point and integer data types, and contains overloads for basic arithmetic operations (i.e.: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> for all types and <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> for integers). However, <em>the <a href="#CheckedNumeric_in-checked_math_h-Non_member-helper-functions">variadic template functions</a> are the preferred API,</em> as they remove type ambiguities and help prevent a number of common errors. The variadic functions can also be more performant, as they eliminate redundant expressions that are unavoidable with the with the operator overloads. (Ideally the compiler should optimize those away, but better to avoid them in the first place.)</p>
<p>Type promotions are a slightly modified version of the [standard C/C++ numeric promotions ](<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions">http://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions</a>) with the two differences being that <em>there is no default promotion to int</em> and <em>bitwise logical operations always return an unsigned of the wider type.</em></p>
<h2><a class="anchor" id="autotoc_md13"></a>
Example</h2>
<div class="fragment"><div class="line">#include &quot;src/base/numerics/checked_math.h&quot;</div>
<div class="line">...</div>
<div class="line">CheckedNumeric&lt;uint32_t&gt; variable = 0;</div>
<div class="line">variable++;</div>
<div class="line">variable--;</div>
<div class="line">if (variable.ValueOrDie() == 0)</div>
<div class="line">  // Fine, |variable| still within valid range.</div>
<div class="line"> </div>
<div class="line">variable--;</div>
<div class="line">variable++;</div>
<div class="line">if (variable.ValueOrDie() == 0)  // Breakpoint or configured CheckHandler</div>
<div class="line">  // Does not happen as variable underflowed.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Members</h2>
<p>The unary negation, increment, and decrement operators are supported, along with the following unary arithmetic methods, which return a new <code>CheckedNumeric</code> as a result of the operation:</p>
<ul>
<li><code><a class="el" href="namespacev8_1_1internal.html#a4cf86377610a7a844281b43c30e7d8b6">Abs()</a></code> - Absolute value.</li>
<li><code>UnsignedAbs()</code> - Absolute value as an equal-width unsigned underlying type (valid for only integral types).</li>
<li><code>Max()</code> - Returns whichever is greater of the current instance or argument. The underlying return type is whichever has the greatest magnitude.</li>
<li><code>Min()</code> - Returns whichever is lowest of the current instance or argument. The underlying return type is whichever has can represent the lowest number in the smallest width (e.g. int8_t over unsigned, int over int8_t, and float over int).</li>
</ul>
<p>The following are for converting <code>CheckedNumeric</code> instances:</p>
<ul>
<li><code>type</code> - The underlying numeric type.</li>
<li><code>AssignIfValid()</code> - Assigns the underlying value to the supplied destination pointer if the value is currently valid and within the range supported by the destination type. Returns true on success.</li>
<li><code>Cast&lt;&gt;()</code> - Instance method returning a <code>CheckedNumeric</code> derived from casting the current instance to a <code>CheckedNumeric</code> of the supplied destination type.</li>
</ul>
<p>*** aside The following member functions return a <code>StrictNumeric</code>, which is valid for comparison and assignment operations, but will trigger a compile failure on attempts to assign to a type of insufficient range. The underlying value can be extracted by an explicit <code>static_cast</code> to the underlying type or any type with sufficient range to represent the underlying type. </p><hr  />
<ul>
<li><code>IsValid()</code> - Returns true if the underlying numeric value is valid (i.e. has not wrapped or saturated and is not the result of an invalid conversion).</li>
<li><code>ValueOrDie()</code> - Returns the underlying value. If the state is not valid this call will trigger a crash by default (but may be overridden by supplying an alternate handler to the template).</li>
<li><code>ValueOrDefault()</code> - Returns the current value, or the supplied default if the state is not valid (but will not crash).</li>
</ul>
<p><b>Comparison operators are explicitly not provided</b> for <code>CheckedNumeric</code> types because they could result in a crash if the type is not in a valid state. Patterns like the following should be used instead:</p>
<div class="fragment"><div class="line"><span class="comment">// Either input or padding (or both) may be arbitrary sizes.</span></div>
<div class="line"><span class="keywordtype">size_t</span> buff_size;</div>
<div class="line"><span class="keywordflow">if</span> (!CheckAdd(input, padding, kHeaderLength).AssignIfValid(&amp;buff_size) ||</div>
<div class="line">     buff_size &gt;= kMaxBuffer) {</div>
<div class="line">  <span class="comment">// Handle an error...</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// Do stuff on success...</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Non-member helper functions</h2>
<p>The following variadic convenience functions, which accept standard arithmetic or <code>CheckedNumeric</code> types, perform arithmetic operations, and return a <code>CheckedNumeric</code> result. The supported functions are:</p>
<ul>
<li><code>CheckAdd()</code> - Addition.</li>
<li><code>CheckSub()</code> - Subtraction.</li>
<li><code>CheckMul()</code> - Multiplication.</li>
<li><code>CheckDiv()</code> - Division.</li>
<li><code>CheckMod()</code> - Modulus (integer only).</li>
<li><code>CheckLsh()</code> - Left integer shift (integer only).</li>
<li><code>CheckRsh()</code> - Right integer shift (integer only).</li>
<li><code>CheckAnd()</code> - Bitwise AND (integer only with unsigned result).</li>
<li><code>CheckOr()</code> - Bitwise OR (integer only with unsigned result).</li>
<li><code>CheckXor()</code> - Bitwise XOR (integer only with unsigned result).</li>
<li><code>CheckMax()</code> - Maximum of supplied arguments.</li>
<li><code>CheckMin()</code> - Minimum of supplied arguments.</li>
</ul>
<p>The following wrapper functions can be used to avoid the template disambiguator syntax when converting a destination type.</p>
<ul>
<li><code>IsValidForType&lt;&gt;()</code> in place of: <code>a.template IsValid&lt;&gt;()</code></li>
<li><code>ValueOrDieForType&lt;&gt;()</code> in place of: <code>a.template ValueOrDie&lt;&gt;()</code></li>
<li><code>ValueOrDefaultForType&lt;&gt;()</code> in place of: <code>a.template ValueOrDefault&lt;&gt;()</code></li>
</ul>
<p>The following general utility methods is are useful for converting from arithmetic types to <code>CheckedNumeric</code> types:</p>
<ul>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#ab105dfb727e62f0757bd8afcc258f437">MakeCheckedNum()</a></code> - Creates a new <code>CheckedNumeric</code> from the underlying type of the supplied arithmetic or directly convertible type.</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
ClampedNumeric&lt;&gt; in clamped_math.h</h1>
<p><code>ClampedNumeric&lt;&gt;</code> implements all the logic and operators for clamped (non-sticky saturating) arithmetic operations and conversions. The <code>ClampedNumeric</code> type implicitly converts back and forth between floating point and integer data types, saturating on assignment as appropriate. It contains overloads for basic arithmetic operations (i.e.: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> for all types and <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code> for integers) along with comparison operators for arithmetic types of any size. However, <em>the [variadic template functions ](#ClampedNumeric_in-clamped_math_h-Non_member-helper-functions) are the preferred API,</em> as they remove type ambiguities and help prevent a number of common errors. The variadic functions can also be more performant, as they eliminate redundant expressions that are unavoidable with the operator overloads. (Ideally the compiler should optimize those away, but better to avoid them in the first place.)</p>
<p>Type promotions are a slightly modified version of the [standard C/C++ numeric promotions ](<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions">http://en.cppreference.com/w/cpp/language/implicit_conversion#Numeric_promotions</a>) with the two differences being that <em>there is no default promotion to int</em> and <em>bitwise logical operations always return an unsigned of the wider type.</em></p>
<p>*** aside Most arithmetic operations saturate normally, to the numeric limit in the direction of the sign. The potentially unusual cases are:</p>
<ul>
<li><b>Division:</b> Division by zero returns the saturated limit in the direction of sign of the dividend (first argument). The one exception is 0/0, which returns zero (although logically is NaN).</li>
<li><b>Modulus:</b> Division by zero returns the dividend (first argument).</li>
<li><b>Left shift:</b> Non-zero values saturate in the direction of the signed limit (max/min), even for shifts larger than the bit width. 0 shifted any amount results in 0.</li>
<li><b>Right shift:</b> Negative values saturate to -1. Positive or 0 saturates to 0. (Effectively just an unbounded arithmetic-right-shift.)</li>
<li><b>Bitwise operations:</b> No saturation; bit pattern is identical to non-saturated bitwise operations. <hr  />
</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Members</h2>
<p>The unary negation, increment, and decrement operators are supported, along with the following unary arithmetic methods, which return a new <code>ClampedNumeric</code> as a result of the operation:</p>
<ul>
<li><code><a class="el" href="namespacev8_1_1internal.html#a4cf86377610a7a844281b43c30e7d8b6">Abs()</a></code> - Absolute value.</li>
<li><code>UnsignedAbs()</code> - Absolute value as an equal-width unsigned underlying type (valid for only integral types).</li>
<li><code>Max()</code> - Returns whichever is greater of the current instance or argument. The underlying return type is whichever has the greatest magnitude.</li>
<li><code>Min()</code> - Returns whichever is lowest of the current instance or argument. The underlying return type is whichever has can represent the lowest number in the smallest width (e.g. int8_t over unsigned, int over int8_t, and float over int).</li>
</ul>
<p>The following are for converting <code>ClampedNumeric</code> instances:</p>
<ul>
<li><code>type</code> - The underlying numeric type.</li>
<li><code>RawValue()</code> - Returns the raw value as the underlying arithmetic type. This is useful when e.g. assigning to an auto type or passing as a deduced template parameter.</li>
<li><code>Cast&lt;&gt;()</code> - Instance method returning a <code>ClampedNumeric</code> derived from casting the current instance to a <code>ClampedNumeric</code> of the supplied destination type.</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Non-member helper functions</h2>
<p>The following variadic convenience functions, which accept standard arithmetic or <code>ClampedNumeric</code> types, perform arithmetic operations, and return a <code>ClampedNumeric</code> result. The supported functions are:</p>
<ul>
<li><code>ClampAdd()</code> - Addition.</li>
<li><code>ClampSub()</code> - Subtraction.</li>
<li><code>ClampMul()</code> - Multiplication.</li>
<li><code>ClampDiv()</code> - Division.</li>
<li><code>ClampMod()</code> - Modulus (integer only).</li>
<li><code>ClampLsh()</code> - Left integer shift (integer only).</li>
<li><code>ClampRsh()</code> - Right integer shift (integer only).</li>
<li><code>ClampAnd()</code> - Bitwise AND (integer only with unsigned result).</li>
<li><code>ClampOr()</code> - Bitwise OR (integer only with unsigned result).</li>
<li><code>ClampXor()</code> - Bitwise XOR (integer only with unsigned result).</li>
<li><code>ClampMax()</code> - Maximum of supplied arguments.</li>
<li><code>ClampMin()</code> - Minimum of supplied arguments.</li>
</ul>
<p>The following is a general utility method that is useful for converting to a <code>ClampedNumeric</code> type:</p>
<ul>
<li><code><a class="el" href="namespacev8_1_1base_1_1internal.html#a45f9069a9866b4bd0b9321d279c79214">MakeClampedNum()</a></code> - Creates a new <code>ClampedNumeric</code> from the underlying type of the supplied arithmetic or directly convertible type. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jun 12 2025 16:01:49 for V8 Project by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
