\hypertarget{classcppgc_1_1Platform}{}\doxysection{cppgc\+::Platform Class Reference}
\label{classcppgc_1_1Platform}\index{cppgc::Platform@{cppgc::Platform}}


{\ttfamily \#include $<$platform.\+h$>$}



Inheritance diagram for cppgc\+::Platform\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=209pt]{classcppgc_1_1Platform__inherit__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{classcppgc_1_1Platform_a3d5cf760f3d741caa002c02e396df858}{$\sim$\+Platform}} ()=default
\item 
virtual \mbox{\hyperlink{namespacecppgc_ae7d41c486a869bec62aa1b8c9c55c142}{Page\+Allocator}} $\ast$ \mbox{\hyperlink{classcppgc_1_1Platform_a495855d4b25ce29041eaa683b066623e}{Get\+Page\+Allocator}} ()=0
\item 
virtual double \mbox{\hyperlink{classcppgc_1_1Platform_a84e8ad12fbf3693eceffe3477166798a}{Monotonically\+Increasing\+Time}} ()=0
\item 
virtual std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{namespacecppgc_a3c2b2bee060b35e6507a2d25c5e5abc7}{Task\+Runner}} $>$ \mbox{\hyperlink{classcppgc_1_1Platform_a0dbe1a8407043f1cf645266b62dbf7f5}{Get\+Foreground\+Task\+Runner}} ()
\item 
virtual std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{namespacecppgc_a3c2b2bee060b35e6507a2d25c5e5abc7}{Task\+Runner}} $>$ \mbox{\hyperlink{classcppgc_1_1Platform_ae48a2caa736eaad9cc827bcad1e2e8c1}{Get\+Foreground\+Task\+Runner}} (\mbox{\hyperlink{namespacev8_a680c1a715d1d5df94b21e8b1ee1bf051}{Task\+Priority}} \mbox{\hyperlink{module-compiler_8cc_a12a507bc765598b5db4100af52f045e3}{priority}})
\item 
virtual std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{namespacecppgc_a4607b4a641e66d8d659a26e3de353799}{Job\+Handle}} $>$ \mbox{\hyperlink{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}{Post\+Job}} (\mbox{\hyperlink{namespacev8_a680c1a715d1d5df94b21e8b1ee1bf051}{Task\+Priority}} \mbox{\hyperlink{module-compiler_8cc_a12a507bc765598b5db4100af52f045e3}{priority}}, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{namespacecppgc_af642e7a654c11a50fc291a85840537c8}{Job\+Task}} $>$ job\+\_\+task)
\item 
virtual \mbox{\hyperlink{namespacecppgc_a28c3d393aadf0a5ef0847ae1657a60bb}{Tracing\+Controller}} $\ast$ \mbox{\hyperlink{classcppgc_1_1Platform_a449d2d2e535fa36e830d59fc43823226}{Get\+Tracing\+Controller}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{classcppgc_1_1Platform}{Platform}} interface used by \mbox{\hyperlink{classcppgc_1_1Heap}{Heap}}. Contains allocators and executors. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classcppgc_1_1Platform_a3d5cf760f3d741caa002c02e396df858}\label{classcppgc_1_1Platform_a3d5cf760f3d741caa002c02e396df858}} 
\index{cppgc::Platform@{cppgc::Platform}!````~Platform@{$\sim$Platform}}
\index{````~Platform@{$\sim$Platform}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{$\sim$Platform()}{~Platform()}}
{\footnotesize\ttfamily virtual cppgc\+::\+Platform\+::$\sim$\+Platform (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classcppgc_1_1Platform_a0dbe1a8407043f1cf645266b62dbf7f5}\label{classcppgc_1_1Platform_a0dbe1a8407043f1cf645266b62dbf7f5}} 
\index{cppgc::Platform@{cppgc::Platform}!GetForegroundTaskRunner@{GetForegroundTaskRunner}}
\index{GetForegroundTaskRunner@{GetForegroundTaskRunner}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{GetForegroundTaskRunner()}{GetForegroundTaskRunner()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily virtual std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{namespacecppgc_a3c2b2bee060b35e6507a2d25c5e5abc7}{Task\+Runner}}$>$ cppgc\+::\+Platform\+::\+Get\+Foreground\+Task\+Runner (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Foreground task runner that should be used by a \mbox{\hyperlink{classcppgc_1_1Heap}{Heap}}. \mbox{\Hypertarget{classcppgc_1_1Platform_ae48a2caa736eaad9cc827bcad1e2e8c1}\label{classcppgc_1_1Platform_ae48a2caa736eaad9cc827bcad1e2e8c1}} 
\index{cppgc::Platform@{cppgc::Platform}!GetForegroundTaskRunner@{GetForegroundTaskRunner}}
\index{GetForegroundTaskRunner@{GetForegroundTaskRunner}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{GetForegroundTaskRunner()}{GetForegroundTaskRunner()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{namespacecppgc_a3c2b2bee060b35e6507a2d25c5e5abc7}{Task\+Runner}}$>$ cppgc\+::\+Platform\+::\+Get\+Foreground\+Task\+Runner (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacev8_a680c1a715d1d5df94b21e8b1ee1bf051}{Task\+Priority}}}]{priority }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Returns a Task\+Runner with a specific $\vert$priority$\vert$ which can be used to post a task on the foreground thread. 

Reimplemented in \mbox{\hyperlink{classcppgc_1_1DefaultPlatform_af26ce14586beb26a1be7dd237fe10635}{cppgc\+::\+Default\+Platform}}.

\mbox{\Hypertarget{classcppgc_1_1Platform_a495855d4b25ce29041eaa683b066623e}\label{classcppgc_1_1Platform_a495855d4b25ce29041eaa683b066623e}} 
\index{cppgc::Platform@{cppgc::Platform}!GetPageAllocator@{GetPageAllocator}}
\index{GetPageAllocator@{GetPageAllocator}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{GetPageAllocator()}{GetPageAllocator()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{namespacecppgc_ae7d41c486a869bec62aa1b8c9c55c142}{Page\+Allocator}}$\ast$ cppgc\+::\+Platform\+::\+Get\+Page\+Allocator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}
the allocator used by cppgc to allocate its heap and various support structures. Returning nullptr results in using the {\ttfamily Page\+Allocator} provided by {\ttfamily \mbox{\hyperlink{namespacecppgc_a725e7d9ef736a78723538b1cf32b9484}{cppgc\+::\+Initialize\+Process()}}} instead. 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{classcppgc_1_1DefaultPlatform_a10b3454d1a07aaaaeeca2c939073abfa}{cppgc\+::\+Default\+Platform}}.

\mbox{\Hypertarget{classcppgc_1_1Platform_a449d2d2e535fa36e830d59fc43823226}\label{classcppgc_1_1Platform_a449d2d2e535fa36e830d59fc43823226}} 
\index{cppgc::Platform@{cppgc::Platform}!GetTracingController@{GetTracingController}}
\index{GetTracingController@{GetTracingController}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{GetTracingController()}{GetTracingController()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacecppgc_a28c3d393aadf0a5ef0847ae1657a60bb}{Tracing\+Controller}} $\ast$ cppgc\+::\+Platform\+::\+Get\+Tracing\+Controller (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Returns an instance of a {\ttfamily Tracing\+Controller}. This must be non-\/nullptr. The default implementation returns an empty {\ttfamily Tracing\+Controller} that consumes trace data without effect. 

Reimplemented in \mbox{\hyperlink{classcppgc_1_1DefaultPlatform_ae90a60665a260ab7ca21f1b1ea8665d0}{cppgc\+::\+Default\+Platform}}.

\mbox{\Hypertarget{classcppgc_1_1Platform_a84e8ad12fbf3693eceffe3477166798a}\label{classcppgc_1_1Platform_a84e8ad12fbf3693eceffe3477166798a}} 
\index{cppgc::Platform@{cppgc::Platform}!MonotonicallyIncreasingTime@{MonotonicallyIncreasingTime}}
\index{MonotonicallyIncreasingTime@{MonotonicallyIncreasingTime}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{MonotonicallyIncreasingTime()}{MonotonicallyIncreasingTime()}}
{\footnotesize\ttfamily virtual double cppgc\+::\+Platform\+::\+Monotonically\+Increasing\+Time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Monotonically increasing time in seconds from an arbitrary fixed point in the past. This function is expected to return at least millisecond-\/precision values. For this reason, it is recommended that the fixed point be no further in the past than the epoch. 

Implemented in \mbox{\hyperlink{classcppgc_1_1DefaultPlatform_af00442dae93371d546837360a6c2705f}{cppgc\+::\+Default\+Platform}}.

\mbox{\Hypertarget{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}\label{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}} 
\index{cppgc::Platform@{cppgc::Platform}!PostJob@{PostJob}}
\index{PostJob@{PostJob}!cppgc::Platform@{cppgc::Platform}}
\doxysubsubsection{\texorpdfstring{PostJob()}{PostJob()}}
{\footnotesize\ttfamily virtual std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{namespacecppgc_a4607b4a641e66d8d659a26e3de353799}{Job\+Handle}}$>$ cppgc\+::\+Platform\+::\+Post\+Job (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacev8_a680c1a715d1d5df94b21e8b1ee1bf051}{Task\+Priority}}}]{priority,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{namespacecppgc_af642e7a654c11a50fc291a85840537c8}{Job\+Task}} $>$}]{job\+\_\+task }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Posts {\ttfamily job\+\_\+task} to run in parallel. Returns a {\ttfamily Job\+Handle} associated with the {\ttfamily Job}, which can be joined or canceled. This avoids degenerate cases\+:
\begin{DoxyItemize}
\item Calling {\ttfamily Call\+On\+Worker\+Thread()} for each work item, causing significant overhead.
\item Fixed number of {\ttfamily Call\+On\+Worker\+Thread()} calls that split the work and might run for a long time. This is problematic when many components post \char`\"{}num cores\char`\"{} tasks and all expect to use all the cores. In these cases, the scheduler lacks context to be fair to multiple same-\/priority requests and/or ability to request lower priority work to yield when high priority work comes in. A canonical implementation of {\ttfamily job\+\_\+task} looks like\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MyJobTask : \textcolor{keyword}{public} \mbox{\hyperlink{namespacecppgc_af642e7a654c11a50fc291a85840537c8}{JobTask}} \{}
\DoxyCodeLine{ \textcolor{keyword}{public}:}
\DoxyCodeLine{  MyJobTask(...) : worker\_queue\_(...) \{\}}
\DoxyCodeLine{  \textcolor{comment}{// JobTask implementation.}}
\DoxyCodeLine{  \textcolor{keywordtype}{void} Run(\mbox{\hyperlink{namespacecppgc_a74aa606ef974ec10b401c6538a239245}{JobDelegate}}* delegate)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{while} (!delegate-\/>ShouldYield()) \{}
\DoxyCodeLine{      \textcolor{comment}{// Smallest unit of work.}}
\DoxyCodeLine{      \textcolor{keyword}{auto} work\_item = worker\_queue\_.TakeWorkItem(); \textcolor{comment}{// Thread safe.}}
\DoxyCodeLine{      \textcolor{keywordflow}{if} (!work\_item) \textcolor{keywordflow}{return};}
\DoxyCodeLine{      ProcessWork(work\_item);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordtype}{size\_t} GetMaxConcurrency()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} worker\_queue\_.GetSize(); \textcolor{comment}{// Thread safe.}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// ...}}
\DoxyCodeLine{\textcolor{keyword}{auto} \mbox{\hyperlink{namespacev8_1_1internal_a70cc472d52abf41855c469f0fc1ed072}{handle}} = \mbox{\hyperlink{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}{PostJob}}(\mbox{\hyperlink{namespacev8_a680c1a715d1d5df94b21e8b1ee1bf051a602dfdb2b16ea7a1f4392dc3d5761f7d}{TaskPriority::kUserVisible}},}
\DoxyCodeLine{                      std::make\_unique<MyJobTask>(...));}
\DoxyCodeLine{\mbox{\hyperlink{namespacev8_1_1internal_a70cc472d52abf41855c469f0fc1ed072}{handle}}-\/>Join();}

\end{DoxyCode}

\end{DoxyItemize}

{\ttfamily \mbox{\hyperlink{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}{Post\+Job()}}} and methods of the returned Job\+Handle/\+Job\+Delegate, must never be called while holding a lock that could be acquired by {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9b6d0cee5615420f30b0db8a4c5e8c3b}{Job\+Task\+::\+Run()}}} or {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9f1505551639903b327baecbeb38f6f7}{Job\+Task\+::\+Get\+Max\+Concurrency()}}} -- that could result in a deadlock. This is because (1) {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9f1505551639903b327baecbeb38f6f7}{Job\+Task\+::\+Get\+Max\+Concurrency()}}} may be invoked while holding internal lock (A), hence {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9f1505551639903b327baecbeb38f6f7}{Job\+Task\+::\+Get\+Max\+Concurrency()}}} can only use a lock (B) if that lock is {\itshape never} held while calling back into {\ttfamily Job\+Handle} from any thread (A=$>$B/B=$>$A deadlock) and (2) {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9b6d0cee5615420f30b0db8a4c5e8c3b}{Job\+Task\+::\+Run()}}} or {\ttfamily \mbox{\hyperlink{classv8_1_1JobTask_a9f1505551639903b327baecbeb38f6f7}{Job\+Task\+::\+Get\+Max\+Concurrency()}}} may be invoked synchronously from {\ttfamily Job\+Handle} (B=$>$Job\+Handle\+::foo=$>$B deadlock).

A sufficient {\ttfamily \mbox{\hyperlink{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}{Post\+Job()}}} implementation that uses the default Job provided in libplatform looks like\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::unique\_ptr<JobHandle> \mbox{\hyperlink{classcppgc_1_1Platform_a6cd9224a397cb79d4c56e3f0dc163c74}{PostJob}}(}
\DoxyCodeLine{    \mbox{\hyperlink{namespacecppgc_a3285e0ac166437006ff97f42ce2fad4c}{TaskPriority}} \mbox{\hyperlink{module-compiler_8cc_a12a507bc765598b5db4100af52f045e3}{priority}}, std::unique\_ptr<JobTask> job\_task)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} std::make\_unique<DefaultJobHandle>(}
\DoxyCodeLine{      std::make\_shared<DefaultJobState>(}
\DoxyCodeLine{          \textcolor{keyword}{this}, std::move(job\_task), kNumThreads));}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{include_2cppgc_2platform_8h}{include/cppgc/platform.\+h}}\item 
\mbox{\hyperlink{heap_2cppgc_2platform_8cc}{heap/cppgc/platform.\+cc}}\end{DoxyCompactItemize}
