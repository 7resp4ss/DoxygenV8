\hypertarget{classv8_1_1internal_1_1JSAtomicsMutex}{}\doxysection{v8\+::internal\+::JSAtomics\+Mutex Class Reference}
\label{classv8_1_1internal_1_1JSAtomicsMutex}\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}


{\ttfamily \#include $<$js-\/atomics-\/synchronization.\+h$>$}



Inheritance diagram for v8\+::internal\+::JSAtomics\+Mutex\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classv8_1_1internal_1_1JSAtomicsMutex__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for v8\+::internal\+::JSAtomics\+Mutex\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_1_1LockGuard}{Lock\+Guard}}
\item 
class \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_1_1LockGuardBase}{Lock\+Guard\+Base}}
\item 
class \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_1_1TryLockGuard}{Try\+Lock\+Guard}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a5200e99c345ef02af2518010f1e00a30}{k\+Mutex\+Async\+Context\+Slot}} = Context\+::MIN\+\_\+\+CONTEXT\+\_\+\+SLOTS
, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a431940ea4c6b6f4d1885ddd882dc54c4}{k\+Unlocked\+Promise\+Async\+Context\+Slot}}
, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42ae64536b44b43e437a759d5033e1aaeea}{k\+Async\+Locked\+Waiter\+Async\+Context\+Slot}}
, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a03001fda7f480885c56f9fb9ba6e0880}{k\+Async\+Context\+Length}}
 \}
\item 
using \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{Async\+Waiter\+Node\+Type}} = \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{v8config_8h_a63258e4bf5dc9fb8c78f881c8405d83b}{V8\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT}} \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aaf1f431fef6b2704f0c784653b8b6ce0}{Try\+Lock}} ()
\item 
void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673}{Unlock}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester)
\item 
\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def}{Is\+Held}} ()
\item 
\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e}{Is\+Current\+Thread\+Owner}} ()
\item 
void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a2f85be184435df82fb19287958d56021}{Unlock\+Async\+Locked\+Mutex}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Foreign}{Foreign}} $>$ async\+\_\+locked\+\_\+waiter\+\_\+wrapper)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSObject}{JSObject}} $>$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b}{Create\+Result\+Object}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$isolate, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Object}{Object}} $>$ \mbox{\hyperlink{namespacev8_1_1internal_ac1a33b5fd9af1653d346746cdb5c1ac0}{value}}, \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} success)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4ebd969fa7c9e3b1087beb252d802a15}{Lock}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout=std\+::nullopt)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a}{Lock\+Async}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, \mbox{\hyperlink{classv8_1_1internal_1_1Handle}{Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ internal\+\_\+locked\+\_\+promise, \mbox{\hyperlink{classv8_1_1internal_1_1MaybeHandle}{Maybe\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ unlocked\+\_\+promise, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{Async\+Waiter\+Node\+Type}} $\ast$$\ast$waiter\+\_\+node, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout=std\+::nullopt)
\item 
static \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a11ead00d22c8ccbb4ff02c13c7f86cdd}{Lock\+Async\+Wrapper\+For\+Wait}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex)
\item 
static \mbox{\hyperlink{classv8_1_1internal_1_1MaybeDirectHandle}{Maybe\+Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ae91cc5f649b3e630c487c544613a67af}{Lock\+Or\+Enqueue\+Promise}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$isolate, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Object}{Object}} $>$ callback, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e}{Lock\+Or\+Enqueue\+Async\+Node}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$isolate, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$node)
\item 
static void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4499c250afa1ee9c1b28d578411f3b9b}{Handle\+Async\+Notify}} (\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$node)
\item 
static void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a21f069a570c076b2d5815f17963de492}{Handle\+Async\+Timeout}} (\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$node)
\item 
static void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a9e9cd92a770254b79df18291f7822111}{Cleanup\+Matching\+Async\+Waiters}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$isolate, \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$node, Dequeue\+Matcher matcher)
\end{DoxyCompactItemize}
\doxysubsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a03131d5a9b29f0f4560fbb7854d9a652}{Is\+Locked\+Field}} = \mbox{\hyperlink{classv8_1_1internal_1_1JSSynchronizationPrimitive_adfcd3a9cc8bcc41b4c6de57c7368a6b6}{JSSynchronization\+Primitive\+::\+Next\+Bit\+Field}}$<$ \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}}, 1 $>$
\end{DoxyCompactItemize}
\doxysubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf}{Set\+Current\+Thread\+As\+Owner}} ()
\item 
void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d}{Clear\+Owner\+Thread}} ()
\item 
std\+::atomic$<$ int32\+\_\+t $>$ $\ast$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}{Atomic\+Owner\+Thread\+Id\+Ptr}} ()
\item 
\mbox{\hyperlink{src_2base_2macros_8h_ab08e353943a53678ac6baafc678f2d81}{V8\+\_\+\+EXPORT\+\_\+\+PRIVATE}} void \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674}{Unlock\+Slow\+Path}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, std\+::atomic$<$ StateT $>$ $\ast$state)
\item 
\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a7ab74296e2ded7c17f1719d198e8f144}{Lock\+JSMutex\+Or\+Dequeue\+Timed\+Out\+Waiter}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, std\+::atomic$<$ StateT $>$ $\ast$state, \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$timed\+\_\+out\+\_\+waiter)
\end{DoxyCompactItemize}
\doxysubsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{src_2base_2macros_8h_ab08e353943a53678ac6baafc678f2d81}{V8\+\_\+\+EXPORT\+\_\+\+PRIVATE}} \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31}{Lock\+Slow\+Path}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401}{Lock\+Async\+Slow\+Path}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$isolate, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state, \mbox{\hyperlink{classv8_1_1internal_1_1Handle}{Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ internal\+\_\+locked\+\_\+promise, \mbox{\hyperlink{classv8_1_1internal_1_1MaybeHandle}{Maybe\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ unlocked\+\_\+promise, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{Async\+Waiter\+Node\+Type}} $\ast$$\ast$waiter\+\_\+node, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7}{Try\+Lock\+Explicit}} (std\+::atomic$<$ StateT $>$ $\ast$state, StateT \&expected)
\item 
static std\+::optional$<$ \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueLockGuard}{Waiter\+Queue\+Lock\+Guard}} $>$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c}{Lock\+Waiter\+Queue\+Or\+JSMutex}} (std\+::atomic$<$ StateT $>$ $\ast$state, StateT \&current\+\_\+state)
\item 
static \mbox{\hyperlink{src_2base_2macros_8h_ab08e353943a53678ac6baafc678f2d81}{V8\+\_\+\+EXPORT\+\_\+\+PRIVATE}} \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a6cd32ae00cc01ca7437d432cab96b10c}{Mutex\+Try\+Lock}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}{Backoff\+Try\+Lock}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state)
\item 
static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01}{Dequeue\+Timed\+Out\+Async\+Waiter}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state, \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$timed\+\_\+out\+\_\+waiter)
\item 
static \mbox{\hyperlink{src_2base_2macros_8h_ab08e353943a53678ac6baafc678f2d81}{V8\+\_\+\+EXPORT\+\_\+\+PRIVATE}} \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}{Maybe\+Enqueue\+Node}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::atomic$<$ StateT $>$ $\ast$state, \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$this\+\_\+waiter)
\item 
{\footnotesize template$<$typename Lock\+Slow\+Path\+Wrapper , typename  = std\+::enable\+\_\+if$<$std\+::is\+\_\+invocable\+\_\+r\+\_\+v$<$                bool, Lock\+Slow\+Path\+Wrapper, std\+::atomic$<$\+State\+T$>$$\ast$$>$$>$$>$ }\\static \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8}{Lock\+Impl}} (\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$requester, \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$ mutex, std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$ timeout, Lock\+Slow\+Path\+Wrapper slow\+\_\+path\+\_\+wrapper)
\end{DoxyCompactItemize}
\doxysubsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr StateT \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{k\+Unlocked\+Uncontended}} = k\+Empty\+State
\item 
static constexpr StateT \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}{k\+Locked\+Uncontended}} = \mbox{\hyperlink{classv8_1_1base_1_1BitField_a70718344d8a4df6c20b3cf9c9b14d0d4}{Is\+Locked\+Field\+::encode}}(\mbox{\hyperlink{namespacev8_1_1internal_a7f5302a7c7fd292ffd4a5f9758bd3686}{true}})
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a328c093d609680cca505905c6d49901a}{Factory}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line 173 of file js-\/atomics-\/synchronization.\+h.



\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}\label{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!AsyncWaiterNodeType@{AsyncWaiterNodeType}}
\index{AsyncWaiterNodeType@{AsyncWaiterNodeType}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{AsyncWaiterNodeType}{AsyncWaiterNodeType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Async\+Waiter\+Node\+Type}} =  \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}}}



Definition at line 177 of file js-\/atomics-\/synchronization.\+h.

\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a03131d5a9b29f0f4560fbb7854d9a652}\label{classv8_1_1internal_1_1JSAtomicsMutex_a03131d5a9b29f0f4560fbb7854d9a652}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!IsLockedField@{IsLockedField}}
\index{IsLockedField@{IsLockedField}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{IsLockedField}{IsLockedField}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a03131d5a9b29f0f4560fbb7854d9a652}{v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Is\+Locked\+Field}} =  \mbox{\hyperlink{classv8_1_1internal_1_1JSSynchronizationPrimitive_adfcd3a9cc8bcc41b4c6de57c7368a6b6}{JSSynchronization\+Primitive\+::\+Next\+Bit\+Field}}$<$\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}}, 1$>$\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 301 of file js-\/atomics-\/synchronization.\+h.



\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42}\label{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42}} 
\doxysubsubsection{\texorpdfstring{anonymous enum}{anonymous enum}}
{\footnotesize\ttfamily anonymous enum}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kMutexAsyncContextSlot@{kMutexAsyncContextSlot}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kMutexAsyncContextSlot@{kMutexAsyncContextSlot}}}\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a5200e99c345ef02af2518010f1e00a30}\label{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a5200e99c345ef02af2518010f1e00a30}} 
k\+Mutex\+Async\+Context\+Slot&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUnlockedPromiseAsyncContextSlot@{kUnlockedPromiseAsyncContextSlot}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kUnlockedPromiseAsyncContextSlot@{kUnlockedPromiseAsyncContextSlot}}}\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a431940ea4c6b6f4d1885ddd882dc54c4}\label{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a431940ea4c6b6f4d1885ddd882dc54c4}} 
k\+Unlocked\+Promise\+Async\+Context\+Slot&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kAsyncLockedWaiterAsyncContextSlot@{kAsyncLockedWaiterAsyncContextSlot}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kAsyncLockedWaiterAsyncContextSlot@{kAsyncLockedWaiterAsyncContextSlot}}}\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42ae64536b44b43e437a759d5033e1aaeea}\label{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42ae64536b44b43e437a759d5033e1aaeea}} 
k\+Async\+Locked\+Waiter\+Async\+Context\+Slot&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kAsyncContextLength@{kAsyncContextLength}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kAsyncContextLength@{kAsyncContextLength}}}\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a03001fda7f480885c56f9fb9ba6e0880}\label{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a03001fda7f480885c56f9fb9ba6e0880}} 
k\+Async\+Context\+Length&\\
\hline

\end{DoxyEnumFields}


Definition at line 275 of file js-\/atomics-\/synchronization.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{275        \{}
\DoxyCodeLine{276     \textcolor{comment}{// The context slot for the js mutex that is locked asynchronously.}}
\DoxyCodeLine{277     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a5200e99c345ef02af2518010f1e00a30}{kMutexAsyncContextSlot}} = \mbox{\hyperlink{classv8_1_1internal_1_1Context_a7a43120c7c95a95be912a46217274266a259e7927638db515902b439e5c4ec513}{Context::MIN\_CONTEXT\_SLOTS}},}
\DoxyCodeLine{278     \textcolor{comment}{// The context slot for the js exposed promise returned by the call to}}
\DoxyCodeLine{279     \textcolor{comment}{// Atomics.Mutex.lockAsync, it should be resolved or rejected after the}}
\DoxyCodeLine{280     \textcolor{comment}{// mutex is released.}}
\DoxyCodeLine{281     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a431940ea4c6b6f4d1885ddd882dc54c4}{kUnlockedPromiseAsyncContextSlot}},}
\DoxyCodeLine{282     \textcolor{comment}{// The isolate keeps track of WaiterQueueNodes for each mutex locked}}
\DoxyCodeLine{283     \textcolor{comment}{// asynchronously, this is so that the lock can be released in case worker}}
\DoxyCodeLine{284     \textcolor{comment}{// termination. The kAsyncLockedWaiterAsyncContextSlot slot is used to store}}
\DoxyCodeLine{285     \textcolor{comment}{// a Foreign wrapping around an ExternalPointerHandle (or raw}}
\DoxyCodeLine{286     \textcolor{comment}{// pointer when pointer compression is disabled) pointing to the}}
\DoxyCodeLine{287     \textcolor{comment}{// WaiterQueueNode so that it can be removed from the list when the lock is}}
\DoxyCodeLine{288     \textcolor{comment}{// released through the usual path.}}
\DoxyCodeLine{289     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42ae64536b44b43e437a759d5033e1aaeea}{kAsyncLockedWaiterAsyncContextSlot}},}
\DoxyCodeLine{290     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42a03001fda7f480885c56f9fb9ba6e0880}{kAsyncContextLength}}}
\DoxyCodeLine{291   \};}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}\label{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!AtomicOwnerThreadIdPtr@{AtomicOwnerThreadIdPtr}}
\index{AtomicOwnerThreadIdPtr@{AtomicOwnerThreadIdPtr}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{AtomicOwnerThreadIdPtr()}{AtomicOwnerThreadIdPtr()}}
{\footnotesize\ttfamily std\+::atomic$<$ int32\+\_\+t $>$ $\ast$ v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Atomic\+Owner\+Thread\+Id\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Definition at line 244 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{244                                                            \{}
\DoxyCodeLine{245   \mbox{\hyperlink{namespaceunibrow_ab0275d47f9778d486eafe88b18c5851d}{int32\_t}}* owner\_thread\_id\_ptr =}
\DoxyCodeLine{246       \textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{namespaceunibrow_ab0275d47f9778d486eafe88b18c5851d}{int32\_t}}*\textcolor{keyword}{>}(field\_address(kOwnerThreadIdOffset));}
\DoxyCodeLine{247   \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacev8_1_1base_a09e03eced9d8997efe04b3d1574d57a9}{base::AsAtomicPtr}}(owner\_thread\_id\_ptr);}
\DoxyCodeLine{248 \}}

\end{DoxyCode}


References v8\+::base\+::\+As\+Atomic\+Ptr().



Referenced by Clear\+Owner\+Thread(), Is\+Current\+Thread\+Owner(), Set\+Current\+Thread\+As\+Owner(), and Unlock\+Slow\+Path().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}\label{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!BackoffTryLock@{BackoffTryLock}}
\index{BackoffTryLock@{BackoffTryLock}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{BackoffTryLock()}{BackoffTryLock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Backoff\+Try\+Lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 598 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{600                                                               \{}
\DoxyCodeLine{601   \textcolor{comment}{// The backoff algorithm is copied from PartitionAlloc's SpinningMutex.}}
\DoxyCodeLine{602   constexpr \textcolor{keywordtype}{int} kSpinCount = 64;}
\DoxyCodeLine{603   constexpr \textcolor{keywordtype}{int} kMaxBackoff = 16;}
\DoxyCodeLine{604 }
\DoxyCodeLine{605   \textcolor{keywordtype}{int} tries = 0;}
\DoxyCodeLine{606   \textcolor{keywordtype}{int} backoff = 1;}
\DoxyCodeLine{607   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{608   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{609     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7}{JSAtomicsMutex::TryLockExplicit}}(state, current\_state)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{610 }
\DoxyCodeLine{611     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} yields = 0; yields < backoff; yields++) \{}
\DoxyCodeLine{612       \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{613       tries++;}
\DoxyCodeLine{614     \}}
\DoxyCodeLine{615 }
\DoxyCodeLine{616     backoff = std::min(kMaxBackoff, backoff << 1);}
\DoxyCodeLine{617   \} \textcolor{keywordflow}{while} (tries < kSpinCount);}
\DoxyCodeLine{618   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{619 \}}

\end{DoxyCode}


References Try\+Lock\+Explicit(), and YIELD\+\_\+\+PROCESSOR.



Referenced by Lock\+Async\+Slow\+Path(), Lock\+Or\+Enqueue\+Async\+Node(), and Lock\+Slow\+Path().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a9e9cd92a770254b79df18291f7822111}\label{classv8_1_1internal_1_1JSAtomicsMutex_a9e9cd92a770254b79df18291f7822111}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!CleanupMatchingAsyncWaiters@{CleanupMatchingAsyncWaiters}}
\index{CleanupMatchingAsyncWaiters@{CleanupMatchingAsyncWaiters}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{CleanupMatchingAsyncWaiters()}{CleanupMatchingAsyncWaiters()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Cleanup\+Matching\+Async\+Waiters (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{isolate,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$}]{node,  }\item[{Dequeue\+Matcher}]{matcher }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 529 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{531                                                                          \{}
\DoxyCodeLine{532   \textcolor{keyword}{auto}* async\_node = \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{LockAsyncWaiterQueueNode}}*\textcolor{keyword}{>}(node);}
\DoxyCodeLine{533   \textcolor{keywordflow}{if} (async\_node-\/>ready\_for\_async\_cleanup\_) \{}
\DoxyCodeLine{534     \textcolor{comment}{// Whenever a node needs to be looked up in the waiter queue we also remove}}
\DoxyCodeLine{535     \textcolor{comment}{// any other matching nodes and mark them as ready for async cleanup. This}}
\DoxyCodeLine{536     \textcolor{comment}{// way we avoid taking the queue lock multiple times, which could slow down}}
\DoxyCodeLine{537     \textcolor{comment}{// other threads.}}
\DoxyCodeLine{538     \textcolor{keywordflow}{return};}
\DoxyCodeLine{539   \}}
\DoxyCodeLine{540   \textcolor{keywordflow}{if} (async\_node-\/>IsEmpty()) \{}
\DoxyCodeLine{541     \textcolor{comment}{// The node's underlying synchronization primitive has been collected, so}}
\DoxyCodeLine{542     \textcolor{comment}{// delete it.}}
\DoxyCodeLine{543     async\_node-\/>SetNotInListForVerification();}
\DoxyCodeLine{544     \textcolor{keywordflow}{return};}
\DoxyCodeLine{545   \}}
\DoxyCodeLine{546   DirectHandle<JSAtomicsMutex> mutex =}
\DoxyCodeLine{547       async\_node-\/>GetSynchronizationPrimitive();}
\DoxyCodeLine{548   std::atomic<StateT>* state = mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{549   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{550 }
\DoxyCodeLine{551   \textcolor{comment}{// The details of updating the state in this function are too complicated}}
\DoxyCodeLine{552   \textcolor{comment}{// for the waiter queue lock guard to manage, so handle the state manually.}}
\DoxyCodeLine{553   \textcolor{keywordflow}{while} (!TryLockWaiterQueueExplicit(state, current\_state)) \{}
\DoxyCodeLine{554     \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{555   \}}
\DoxyCodeLine{556 }
\DoxyCodeLine{557   \textcolor{keywordtype}{bool} was\_locked\_by\_this\_thread = mutex-\/>IsCurrentThreadOwner();}
\DoxyCodeLine{558   WaiterQueueNode* waiter\_head =}
\DoxyCodeLine{559       mutex-\/>DestructivelyGetWaiterQueueHead(isolate);}
\DoxyCodeLine{560   \textcolor{keywordflow}{if} (waiter\_head) \{}
\DoxyCodeLine{561     \textcolor{comment}{// Dequeue all the matching waiters.}}
\DoxyCodeLine{562     \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_a0cae6ce82fdd7c88fe431afa22093868}{WaiterQueueNode::DequeueAllMatchingForAsyncCleanup}}(\&waiter\_head, matcher);}
\DoxyCodeLine{563     \textcolor{keywordflow}{if} (!async\_node-\/>ready\_for\_async\_cleanup\_) \{}
\DoxyCodeLine{564       \textcolor{comment}{// The node was not in the queue, so it has already being notified.}}
\DoxyCodeLine{565       \textcolor{comment}{// Notify the next head unless the lock is already taken by a different}}
\DoxyCodeLine{566       \textcolor{comment}{// thread or the queue may stall.}}
\DoxyCodeLine{567       \textcolor{keywordflow}{if} (waiter\_head \&\& (!\mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(current\_state) ||}
\DoxyCodeLine{568                           was\_locked\_by\_this\_thread)) \{}
\DoxyCodeLine{569         \textcolor{comment}{// Notify the next head unless the lock is already taken, in which case}}
\DoxyCodeLine{570         \textcolor{comment}{// the lock owner will notify the next waiter.}}
\DoxyCodeLine{571         WaiterQueueNode* old\_head = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_ab5c593f10eda6b809da72dda2e1690f2}{WaiterQueueNode::Dequeue}}(\&waiter\_head);}
\DoxyCodeLine{572         old\_head-\/>Notify();}
\DoxyCodeLine{573       \}}
\DoxyCodeLine{574     \}}
\DoxyCodeLine{575   \}}
\DoxyCodeLine{576   StateT new\_state = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}};}
\DoxyCodeLine{577   new\_state = mutex-\/>SetWaiterQueueHead(isolate, waiter\_head, new\_state);}
\DoxyCodeLine{578   new\_state = IsWaiterQueueLockedField::update(new\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{579   \textcolor{keywordflow}{if} (was\_locked\_by\_this\_thread) \{}
\DoxyCodeLine{580     mutex-\/>ClearOwnerThread();}
\DoxyCodeLine{581     new\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(new\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{582     state-\/>store(new\_state, std::memory\_order\_release);}
\DoxyCodeLine{583   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{584     SetWaiterQueueStateOnly(state, new\_state);}
\DoxyCodeLine{585   \}}
\DoxyCodeLine{586 \}}

\end{DoxyCode}


References v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::decode(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue\+All\+Matching\+For\+Async\+Cleanup(), k\+Unlocked\+Uncontended, v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Notify(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Set\+Not\+In\+List\+For\+Verification(), v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::update(), and YIELD\+\_\+\+PROCESSOR.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a9e9cd92a770254b79df18291f7822111_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d}\label{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!ClearOwnerThread@{ClearOwnerThread}}
\index{ClearOwnerThread@{ClearOwnerThread}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{ClearOwnerThread()}{ClearOwnerThread()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Clear\+Owner\+Thread (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Definition at line 239 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{239                                       \{}
\DoxyCodeLine{240   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}{AtomicOwnerThreadIdPtr}}()-\/>store(\mbox{\hyperlink{classv8_1_1internal_1_1ThreadId_ade3e1a41d03f0f9f593c7d35c4cafa6c}{ThreadId::Invalid}}().ToInteger(),}
\DoxyCodeLine{241                                   std::memory\_order\_relaxed);}
\DoxyCodeLine{242 \}}

\end{DoxyCode}


References Atomic\+Owner\+Thread\+Id\+Ptr(), and v8\+::internal\+::\+Thread\+Id\+::\+Invalid().



Referenced by Unlock().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b}\label{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!CreateResultObject@{CreateResultObject}}
\index{CreateResultObject@{CreateResultObject}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{CreateResultObject()}{CreateResultObject()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSObject}{JSObject}} $>$ v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Create\+Result\+Object (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{isolate,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Object}{Object}} $>$}]{value,  }\item[{\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}}}]{success }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 516 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{517                                                                 \{}
\DoxyCodeLine{518   DirectHandle<JSObject> \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}} =}
\DoxyCodeLine{519       isolate-\/>factory()-\/>NewJSObject(isolate-\/>object\_function());}
\DoxyCodeLine{520   DirectHandle<Object> success\_value = isolate-\/>factory()-\/>ToBoolean(success);}
\DoxyCodeLine{521   \mbox{\hyperlink{classv8_1_1internal_1_1JSObject_a16c9b19de5218c056da014960fba72ae}{JSObject::AddProperty}}(isolate, \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}}, \textcolor{stringliteral}{"{}value"{}}, \mbox{\hyperlink{namespacev8_1_1internal_ac1a33b5fd9af1653d346746cdb5c1ac0}{value}},}
\DoxyCodeLine{522                         \mbox{\hyperlink{namespacev8_1_1internal_a352f65439007f2f1b85c997c1ba11436a0e9b4052bcf7e2475e8bbf8f436bf370}{PropertyAttributes::NONE}});}
\DoxyCodeLine{523   \mbox{\hyperlink{classv8_1_1internal_1_1JSObject_a16c9b19de5218c056da014960fba72ae}{JSObject::AddProperty}}(isolate, \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}}, \textcolor{stringliteral}{"{}success"{}}, success\_value,}
\DoxyCodeLine{524                         \mbox{\hyperlink{namespacev8_1_1internal_a352f65439007f2f1b85c997c1ba11436a0e9b4052bcf7e2475e8bbf8f436bf370}{PropertyAttributes::NONE}});}
\DoxyCodeLine{525   \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}};}
\DoxyCodeLine{526 \}}

\end{DoxyCode}


References v8\+::internal\+::\+JSObject\+::\+Add\+Property(), v8\+::internal\+::\+Isolate\+::factory(), v8\+::internal\+::\+Factory\+::\+New\+JSObject(), v8\+::internal\+::\+NONE, v8\+::base\+::internal\+::result, v8\+::internal\+::\+Factory\+Base$<$ Impl $>$\+::\+To\+Boolean(), and v8\+::internal\+::value.



Referenced by v8\+::internal\+::\+BUILTIN(), and Handle\+Async\+Timeout().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01}\label{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!DequeueTimedOutAsyncWaiter@{DequeueTimedOutAsyncWaiter}}
\index{DequeueTimedOutAsyncWaiter@{DequeueTimedOutAsyncWaiter}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{DequeueTimedOutAsyncWaiter()}{DequeueTimedOutAsyncWaiter()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Dequeue\+Timed\+Out\+Async\+Waiter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$}]{timed\+\_\+out\+\_\+waiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 978 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{980                                                                  \{}
\DoxyCodeLine{981   \textcolor{comment}{// First acquire the queue lock, which is itself a spinlock.}}
\DoxyCodeLine{982   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{983   \textcolor{comment}{// There are no waiters, but the js mutex lock may be held by another thread.}}
\DoxyCodeLine{984   \textcolor{keywordflow}{if} (!HasWaitersField::decode(current\_state)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{985 }
\DoxyCodeLine{986   \textcolor{comment}{// The details of updating the state in this function are too complicated}}
\DoxyCodeLine{987   \textcolor{comment}{// for the waiter queue lock guard to manage, so handle the state manually.}}
\DoxyCodeLine{988   \textcolor{keywordflow}{while} (!TryLockWaiterQueueExplicit(state, current\_state)) \{}
\DoxyCodeLine{989     \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{990   \}}
\DoxyCodeLine{991 }
\DoxyCodeLine{992   \textcolor{comment}{// Get the waiter queue head.}}
\DoxyCodeLine{993   WaiterQueueNode* waiter\_head =}
\DoxyCodeLine{994       mutex-\/>DestructivelyGetWaiterQueueHead(requester);}
\DoxyCodeLine{995 }
\DoxyCodeLine{996   \textcolor{keywordflow}{if} (waiter\_head == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{997     \textcolor{comment}{// The queue is empty but the js mutex lock may be held by another thread,}}
\DoxyCodeLine{998     \textcolor{comment}{// release the waiter queue bit without changing the "{}is locked"{} bit.}}
\DoxyCodeLine{999     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(!HasWaitersField::decode(current\_state));}
\DoxyCodeLine{1000     SetWaiterQueueStateOnly(state, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}});}
\DoxyCodeLine{1001     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1002   \}}
\DoxyCodeLine{1003 }
\DoxyCodeLine{1004   WaiterQueueNode* dequeued\_node = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_ae672d68e7aa4d9a4e071c204a98ce022}{WaiterQueueNode::DequeueMatching}}(}
\DoxyCodeLine{1005       \&waiter\_head,}
\DoxyCodeLine{1006       [\&](WaiterQueueNode* node) \{ \textcolor{keywordflow}{return} node == timed\_out\_waiter; \});}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008   \textcolor{comment}{// Release the queue lock and install the new waiter queue head.}}
\DoxyCodeLine{1009   \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(state-\/>load(),}
\DoxyCodeLine{1010             IsWaiterQueueLockedField::update(current\_state, \textcolor{keyword}{true}));}
\DoxyCodeLine{1011   StateT new\_state = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}};}
\DoxyCodeLine{1012   new\_state = mutex-\/>SetWaiterQueueHead(requester, waiter\_head, new\_state);}
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014   SetWaiterQueueStateOnly(state, new\_state);}
\DoxyCodeLine{1015   \textcolor{keywordflow}{return} dequeued\_node != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1016 \}}

\end{DoxyCode}


References v8\+::internal\+::\+DCHECK(), DCHECK\+\_\+\+EQ, v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue\+Matching(), k\+Unlocked\+Uncontended, and YIELD\+\_\+\+PROCESSOR.



Referenced by Handle\+Async\+Timeout().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a4499c250afa1ee9c1b28d578411f3b9b}\label{classv8_1_1internal_1_1JSAtomicsMutex_a4499c250afa1ee9c1b28d578411f3b9b}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!HandleAsyncNotify@{HandleAsyncNotify}}
\index{HandleAsyncNotify@{HandleAsyncNotify}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{HandleAsyncNotify()}{HandleAsyncNotify()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Handle\+Async\+Notify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1057 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{1057                                                                        \{}
\DoxyCodeLine{1058   Isolate* requester = waiter-\/>requester\_;}
\DoxyCodeLine{1059   HandleScope scope(requester);}
\DoxyCodeLine{1060 }
\DoxyCodeLine{1061   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a67bd29db07c711b0fb11ff1c324ebb60}{V8\_UNLIKELY}}(waiter-\/>native\_context\_.IsEmpty())) \{}
\DoxyCodeLine{1062     \textcolor{comment}{// The native context was destroyed, so the promise was already removed. But}}
\DoxyCodeLine{1063     \textcolor{comment}{// it is possible that other threads are holding references to the}}
\DoxyCodeLine{1064     \textcolor{comment}{// synchronization primitive. Try to notify the next waiter.}}
\DoxyCodeLine{1065     \textcolor{keywordflow}{if} (!waiter-\/>synchronization\_primitive\_.IsEmpty()) \{}
\DoxyCodeLine{1066       DirectHandle<JSAtomicsMutex> js\_mutex =}
\DoxyCodeLine{1067           waiter-\/>GetSynchronizationPrimitive();}
\DoxyCodeLine{1068       std::atomic<StateT>* state = js\_mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{1069       StateT current\_state = state-\/>load(std::memory\_order\_acquire);}
\DoxyCodeLine{1070       \textcolor{keywordflow}{if} (HasWaitersField::decode(current\_state)) \{}
\DoxyCodeLine{1071         \textcolor{comment}{// Another thread might take the lock while we are notifying the next}}
\DoxyCodeLine{1072         \textcolor{comment}{// waiter, so manually release the queue lock without changing the}}
\DoxyCodeLine{1073         \textcolor{comment}{// IsLockedField bit.}}
\DoxyCodeLine{1074         \textcolor{keywordflow}{while} (!TryLockWaiterQueueExplicit(state, current\_state)) \{}
\DoxyCodeLine{1075           \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{1076         \}}
\DoxyCodeLine{1077         WaiterQueueNode* waiter\_head =}
\DoxyCodeLine{1078             js\_mutex-\/>DestructivelyGetWaiterQueueHead(requester);}
\DoxyCodeLine{1079         \textcolor{keywordflow}{if} (waiter\_head) \{}
\DoxyCodeLine{1080           WaiterQueueNode* old\_head = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_ab5c593f10eda6b809da72dda2e1690f2}{WaiterQueueNode::Dequeue}}(\&waiter\_head);}
\DoxyCodeLine{1081           old\_head-\/>Notify();}
\DoxyCodeLine{1082         \}}
\DoxyCodeLine{1083         StateT new\_state =}
\DoxyCodeLine{1084             js\_mutex-\/>SetWaiterQueueHead(requester, waiter\_head, kEmptyState);}
\DoxyCodeLine{1085         new\_state = IsWaiterQueueLockedField::update(new\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{1086         SetWaiterQueueStateOnly(state, new\_state);}
\DoxyCodeLine{1087       \}}
\DoxyCodeLine{1088     \}}
\DoxyCodeLine{1089     \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_a52115608b23a4b7d2d5e8fd0ffffa1d0}{LockAsyncWaiterQueueNode::RemoveFromAsyncWaiterQueueList}}(waiter);}
\DoxyCodeLine{1090     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1091   \}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093   \mbox{\hyperlink{classv8_1_1Context_1_1Scope}{v8::Context::Scope}} contextScope(waiter-\/>GetNativeContext());}
\DoxyCodeLine{1094   DirectHandle<JSAtomicsMutex> js\_mutex = waiter-\/>GetSynchronizationPrimitive();}
\DoxyCodeLine{1095   DirectHandle<JSPromise> promise = waiter-\/>GetInternalWaitingPromise();}
\DoxyCodeLine{1096   \textcolor{keywordtype}{bool} locked = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e}{LockOrEnqueueAsyncNode}}(requester, js\_mutex, waiter);}
\DoxyCodeLine{1097   \textcolor{keywordflow}{if} (locked) \{}
\DoxyCodeLine{1098     \textcolor{keywordflow}{if} (waiter-\/>timeout\_task\_id\_ != \mbox{\hyperlink{classv8_1_1internal_1_1CancelableTaskManager_aeced01d51e2e17fe43f5286404519146}{CancelableTaskManager::kInvalidTaskId}}) \{}
\DoxyCodeLine{1099       \mbox{\hyperlink{namespacev8_1_1internal_a4a7a0d7631497f73ac7e69b8cfd67a66}{TryAbortResult}} abort\_result =}
\DoxyCodeLine{1100           requester-\/>cancelable\_task\_manager()-\/>TryAbort(}
\DoxyCodeLine{1101               waiter-\/>timeout\_task\_id\_);}
\DoxyCodeLine{1102       \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(abort\_result, \mbox{\hyperlink{namespacev8_1_1internal_a4a7a0d7631497f73ac7e69b8cfd67a66ac6e752bc3177d9fc3f0c9bc51604d37f}{TryAbortResult::kTaskAborted}});}
\DoxyCodeLine{1103       \mbox{\hyperlink{src_2base_2macros_8h_a280b0798f270f4b3f361c9ab64832956}{USE}}(abort\_result);}
\DoxyCodeLine{1104     \}}
\DoxyCodeLine{1105     \textcolor{keywordflow}{if} (waiter-\/>unlocked\_promise\_.IsEmpty()) \{}
\DoxyCodeLine{1106       \textcolor{comment}{// This node came from an async wait notify giving control back to an}}
\DoxyCodeLine{1107       \textcolor{comment}{// async lock call, so we don't need to put the node in the locked waiter}}
\DoxyCodeLine{1108       \textcolor{comment}{// list because the original LockAsycWaiterQueueNode is already in}}
\DoxyCodeLine{1109       \textcolor{comment}{// the locked waiter list.}}
\DoxyCodeLine{1110       \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_a52115608b23a4b7d2d5e8fd0ffffa1d0}{LockAsyncWaiterQueueNode::RemoveFromAsyncWaiterQueueList}}(waiter);}
\DoxyCodeLine{1111     \}}
\DoxyCodeLine{1112     js\_mutex-\/>SetCurrentThreadAsOwner();}
\DoxyCodeLine{1113     \textcolor{keyword}{auto} resolve\_result =}
\DoxyCodeLine{1114         \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise_ab5498a7e4026703f904ad2ab3018c250}{JSPromise::Resolve}}(promise, requester-\/>factory()-\/>undefined\_value());}
\DoxyCodeLine{1115     \mbox{\hyperlink{src_2base_2macros_8h_a280b0798f270f4b3f361c9ab64832956}{USE}}(resolve\_result);}
\DoxyCodeLine{1116     \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02js-atomics-synchronization_8cc_03_adb32c9fd08754d52ac771254297ecd44}{RemovePromiseFromNativeContext}}(requester, promise);}
\DoxyCodeLine{1117   \}}
\DoxyCodeLine{1118 \}}

\end{DoxyCode}


References v8\+::internal\+::\+Isolate\+::cancelable\+\_\+task\+\_\+manager(), DCHECK\+\_\+\+EQ, v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue(), v8\+::internal\+::\+Isolate\+::factory(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Internal\+Waiting\+Promise(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Native\+Context(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Synchronization\+Primitive(), v8\+::api\+\_\+internal\+::\+Indirect\+Handle\+Base\+::\+Is\+Empty(), v8\+::internal\+::\+Cancelable\+Task\+Manager\+::k\+Invalid\+Task\+Id, v8\+::internal\+::k\+Task\+Aborted, Lock\+Or\+Enqueue\+Async\+Node(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::native\+\_\+context\+\_\+, v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Notify(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Remove\+From\+Async\+Waiter\+Queue\+List(), v8\+::internal\+::anonymous\+\_\+namespace\{js-\/atomics-\/synchronization.\+cc\}\+::\+Remove\+Promise\+From\+Native\+Context(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::requester\+\_\+, v8\+::internal\+::\+JSPromise\+::\+Resolve(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::synchronization\+\_\+primitive\+\_\+, v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::timeout\+\_\+task\+\_\+id\+\_\+, v8\+::internal\+::\+Cancelable\+Task\+Manager\+::\+Try\+Abort(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::unlocked\+\_\+promise\+\_\+, USE, V8\+\_\+\+UNLIKELY, and YIELD\+\_\+\+PROCESSOR.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a4499c250afa1ee9c1b28d578411f3b9b_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a21f069a570c076b2d5815f17963de492}\label{classv8_1_1internal_1_1JSAtomicsMutex_a21f069a570c076b2d5815f17963de492}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!HandleAsyncTimeout@{HandleAsyncTimeout}}
\index{HandleAsyncTimeout@{HandleAsyncTimeout}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{HandleAsyncTimeout()}{HandleAsyncTimeout()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Handle\+Async\+Timeout (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1019 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{1019                                                                         \{}
\DoxyCodeLine{1020   Isolate* requester = waiter-\/>requester\_;}
\DoxyCodeLine{1021   HandleScope scope(requester);}
\DoxyCodeLine{1022 }
\DoxyCodeLine{1023   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a67bd29db07c711b0fb11ff1c324ebb60}{V8\_UNLIKELY}}(waiter-\/>native\_context\_.IsEmpty())) \{}
\DoxyCodeLine{1024     \textcolor{comment}{// The native context was destroyed so the lock\_promise was already removed}}
\DoxyCodeLine{1025     \textcolor{comment}{// from the native context. Remove the node from the async unlocked waiter}}
\DoxyCodeLine{1026     \textcolor{comment}{// list.}}
\DoxyCodeLine{1027     \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_a52115608b23a4b7d2d5e8fd0ffffa1d0}{LockAsyncWaiterQueueNode::RemoveFromAsyncWaiterQueueList}}(waiter);}
\DoxyCodeLine{1028     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1029   \}}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031   \mbox{\hyperlink{classv8_1_1Context_1_1Scope}{v8::Context::Scope}} contextScope(waiter-\/>GetNativeContext());}
\DoxyCodeLine{1032   DirectHandle<JSAtomicsMutex> js\_mutex = waiter-\/>GetSynchronizationPrimitive();}
\DoxyCodeLine{1033 }
\DoxyCodeLine{1034   \textcolor{keywordtype}{bool} dequeued = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab4c5854aa0c92c8e1e140b44fddcca01}{JSAtomicsMutex::DequeueTimedOutAsyncWaiter}}(}
\DoxyCodeLine{1035       requester, js\_mutex, js\_mutex-\/>AtomicStatePtr(), waiter);}
\DoxyCodeLine{1036   \textcolor{comment}{// If the waiter is no longer in the queue, then its corresponding notify}}
\DoxyCodeLine{1037   \textcolor{comment}{// task is already in the event loop, this doesn't guarantee that the lock}}
\DoxyCodeLine{1038   \textcolor{comment}{// will be taken by the time the notify task runs, so cancel the notify task.}}
\DoxyCodeLine{1039   \textcolor{keywordflow}{if} (!dequeued) \{}
\DoxyCodeLine{1040     \mbox{\hyperlink{namespacev8_1_1internal_a4a7a0d7631497f73ac7e69b8cfd67a66}{TryAbortResult}} abort\_result =}
\DoxyCodeLine{1041         requester-\/>cancelable\_task\_manager()-\/>TryAbort(waiter-\/>notify\_task\_id\_);}
\DoxyCodeLine{1042     \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(abort\_result, \mbox{\hyperlink{namespacev8_1_1internal_a4a7a0d7631497f73ac7e69b8cfd67a66ac6e752bc3177d9fc3f0c9bc51604d37f}{TryAbortResult::kTaskAborted}});}
\DoxyCodeLine{1043     \mbox{\hyperlink{src_2base_2macros_8h_a280b0798f270f4b3f361c9ab64832956}{USE}}(abort\_result);}
\DoxyCodeLine{1044   \}}
\DoxyCodeLine{1045 }
\DoxyCodeLine{1046   DirectHandle<JSPromise> lock\_promise = waiter-\/>GetInternalWaitingPromise();}
\DoxyCodeLine{1047   DirectHandle<JSPromise> lock\_async\_promise = waiter-\/>GetUnlockedPromise();}
\DoxyCodeLine{1048   DirectHandle<JSObject> \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}} = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a8de8fcc5f5164f1a1bf927ad2eef486b}{CreateResultObject}}(}
\DoxyCodeLine{1049       requester, requester-\/>factory()-\/>undefined\_value(), \textcolor{keyword}{false});}
\DoxyCodeLine{1050   \textcolor{keyword}{auto} resolve\_result = \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise_ab5498a7e4026703f904ad2ab3018c250}{JSPromise::Resolve}}(lock\_async\_promise, \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}});}
\DoxyCodeLine{1051   \mbox{\hyperlink{src_2base_2macros_8h_a280b0798f270f4b3f361c9ab64832956}{USE}}(resolve\_result);}
\DoxyCodeLine{1052   \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_a52115608b23a4b7d2d5e8fd0ffffa1d0}{LockAsyncWaiterQueueNode::RemoveFromAsyncWaiterQueueList}}(waiter);}
\DoxyCodeLine{1053   \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02js-atomics-synchronization_8cc_03_adb32c9fd08754d52ac771254297ecd44}{RemovePromiseFromNativeContext}}(requester, lock\_promise);}
\DoxyCodeLine{1054 \}}

\end{DoxyCode}


References v8\+::internal\+::\+Isolate\+::cancelable\+\_\+task\+\_\+manager(), Create\+Result\+Object(), DCHECK\+\_\+\+EQ, Dequeue\+Timed\+Out\+Async\+Waiter(), v8\+::internal\+::\+Isolate\+::factory(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Internal\+Waiting\+Promise(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Native\+Context(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Synchronization\+Primitive(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Get\+Unlocked\+Promise(), v8\+::api\+\_\+internal\+::\+Indirect\+Handle\+Base\+::\+Is\+Empty(), v8\+::internal\+::k\+Task\+Aborted, v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::native\+\_\+context\+\_\+, v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::notify\+\_\+task\+\_\+id\+\_\+, v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Remove\+From\+Async\+Waiter\+Queue\+List(), v8\+::internal\+::anonymous\+\_\+namespace\{js-\/atomics-\/synchronization.\+cc\}\+::\+Remove\+Promise\+From\+Native\+Context(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::requester\+\_\+, v8\+::internal\+::\+JSPromise\+::\+Resolve(), v8\+::base\+::internal\+::result, v8\+::internal\+::\+Cancelable\+Task\+Manager\+::\+Try\+Abort(), USE, and V8\+\_\+\+UNLIKELY.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a21f069a570c076b2d5815f17963de492_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e}\label{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!IsCurrentThreadOwner@{IsCurrentThreadOwner}}
\index{IsCurrentThreadOwner@{IsCurrentThreadOwner}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{IsCurrentThreadOwner()}{IsCurrentThreadOwner()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Is\+Current\+Thread\+Owner (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 227 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{227                                           \{}
\DoxyCodeLine{228   \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}} = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}{AtomicOwnerThreadIdPtr}}()-\/>load(std::memory\_order\_relaxed) ==}
\DoxyCodeLine{229                 \mbox{\hyperlink{classv8_1_1internal_1_1ThreadId_a81c60d3524b03db2f154b7f682e7796f}{ThreadId::Current}}().\mbox{\hyperlink{classv8_1_1internal_1_1ThreadId_a17819bcea6f016c8bb0615d52c8a52aa}{ToInteger}}();}
\DoxyCodeLine{230   \mbox{\hyperlink{src_2base_2logging_8h_a96a75539aa82216cdde2250a11126ea0}{DCHECK\_IMPLIES}}(\mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}}, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def}{IsHeld}}());}
\DoxyCodeLine{231   \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}};}
\DoxyCodeLine{232 \}}

\end{DoxyCode}


References Atomic\+Owner\+Thread\+Id\+Ptr(), v8\+::internal\+::\+Thread\+Id\+::\+Current(), DCHECK\+\_\+\+IMPLIES, Is\+Held(), v8\+::base\+::internal\+::result, and v8\+::internal\+::\+Thread\+Id\+::\+To\+Integer().



Referenced by Unlock(), and Unlock\+Async\+Locked\+Mutex().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def}\label{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!IsHeld@{IsHeld}}
\index{IsHeld@{IsHeld}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{IsHeld()}{IsHeld()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Is\+Held (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 222 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{222                             \{}
\DoxyCodeLine{223   \textcolor{keywordflow}{return} \mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(}
\DoxyCodeLine{224       AtomicStatePtr()-\/>load(std::memory\_order\_relaxed));}
\DoxyCodeLine{225 \}}

\end{DoxyCode}


References v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::decode().



Referenced by Is\+Current\+Thread\+Owner().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a8c80b0d6206c38b9f19ab2f0624c5def_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a4ebd969fa7c9e3b1087beb252d802a15}\label{classv8_1_1internal_1_1JSAtomicsMutex_a4ebd969fa7c9e3b1087beb252d802a15}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!Lock@{Lock}}
\index{Lock@{Lock}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{Lock()}{Lock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Definition at line 182 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{184                                                               \{}
\DoxyCodeLine{185   \textcolor{keywordflow}{return} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8}{LockImpl}}(requester, mutex, timeout, [=](std::atomic<StateT>* state) \{}
\DoxyCodeLine{186     \textcolor{keywordflow}{return} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31}{LockSlowPath}}(requester, mutex, state, timeout);}
\DoxyCodeLine{187   \});}
\DoxyCodeLine{188 \}}

\end{DoxyCode}


References Lock\+Impl(), and Lock\+Slow\+Path().



Referenced by v8\+::internal\+::\+JSAtomics\+Condition\+::\+Wait\+For().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a4ebd969fa7c9e3b1087beb252d802a15_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a4ebd969fa7c9e3b1087beb252d802a15_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a}\label{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockAsync@{LockAsync}}
\index{LockAsync@{LockAsync}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockAsync()}{LockAsync()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Handle}{Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$}]{internal\+\_\+locked\+\_\+promise,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1MaybeHandle}{Maybe\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$}]{unlocked\+\_\+promise,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{Async\+Waiter\+Node\+Type}} $\ast$$\ast$}]{waiter\+\_\+node,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout = {\ttfamily std\+:\+:nullopt} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 862 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{867                                                                    \{}
\DoxyCodeLine{868   \textcolor{keywordtype}{bool} locked =}
\DoxyCodeLine{869       \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8}{LockImpl}}(requester, mutex, timeout, [=](std::atomic<StateT>* state) \{}
\DoxyCodeLine{870         \textcolor{keywordflow}{return} \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401}{LockAsyncSlowPath}}(requester, mutex, state,}
\DoxyCodeLine{871                                  internal\_locked\_promise, unlocked\_promise,}
\DoxyCodeLine{872                                  waiter\_node, timeout);}
\DoxyCodeLine{873       \});}
\DoxyCodeLine{874   \textcolor{keywordflow}{if} (locked) \{}
\DoxyCodeLine{875     \textcolor{comment}{// Resolve `internal\_locked\_promise` instead of synchronously running the}}
\DoxyCodeLine{876     \textcolor{comment}{// callback. This guarantees that the callback is run in a microtask}}
\DoxyCodeLine{877     \textcolor{comment}{// regardless of the current state of the mutex.}}
\DoxyCodeLine{878     MaybeDirectHandle<Object> \mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}} = \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise_ab5498a7e4026703f904ad2ab3018c250}{JSPromise::Resolve}}(}
\DoxyCodeLine{879         internal\_locked\_promise, requester-\/>factory()-\/>undefined\_value());}
\DoxyCodeLine{880     \mbox{\hyperlink{src_2base_2macros_8h_a280b0798f270f4b3f361c9ab64832956}{USE}}(\mbox{\hyperlink{namespacev8_1_1base_1_1internal_a9840f2bf0b4780133662292486d0bc01}{result}});}
\DoxyCodeLine{881   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{882     \textcolor{comment}{// If the promise is not resolved, keep it alive in a set in the native}}
\DoxyCodeLine{883     \textcolor{comment}{// context. The promise will be resolved and remove from the set in}}
\DoxyCodeLine{884     \textcolor{comment}{// `JSAtomicsMutex::HandleAsyncNotify` or}}
\DoxyCodeLine{885     \textcolor{comment}{// `JSAtomicsMutex::HandleAsyncTimeout`.}}
\DoxyCodeLine{886     \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02js-atomics-synchronization_8cc_03_a97622f0c584c7ed91eab0d5cd7a53470}{AddPromiseToNativeContext}}(requester, internal\_locked\_promise);}
\DoxyCodeLine{887   \}}
\DoxyCodeLine{888   \textcolor{keywordflow}{return} locked;}
\DoxyCodeLine{889 \}}

\end{DoxyCode}


References v8\+::internal\+::anonymous\+\_\+namespace\{js-\/atomics-\/synchronization.\+cc\}\+::\+Add\+Promise\+To\+Native\+Context(), v8\+::internal\+::\+Isolate\+::factory(), Lock\+Async\+Slow\+Path(), Lock\+Impl(), v8\+::internal\+::\+JSPromise\+::\+Resolve(), v8\+::base\+::internal\+::result, and USE.



Referenced by Lock\+Async\+Wrapper\+For\+Wait(), and Lock\+Or\+Enqueue\+Promise().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401}\label{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockAsyncSlowPath@{LockAsyncSlowPath}}
\index{LockAsyncSlowPath@{LockAsyncSlowPath}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockAsyncSlowPath()}{LockAsyncSlowPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Async\+Slow\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{isolate,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Handle}{Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$}]{internal\+\_\+locked\+\_\+promise,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1MaybeHandle}{Maybe\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$}]{unlocked\+\_\+promise,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{Async\+Waiter\+Node\+Type}} $\ast$$\ast$}]{waiter\+\_\+node,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 902 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{907                                         \{}
\DoxyCodeLine{908   \textcolor{comment}{// Spin for a little bit to try to acquire the lock, so as to be fast under}}
\DoxyCodeLine{909   \textcolor{comment}{// microcontention.}}
\DoxyCodeLine{910   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}{BackoffTryLock}}(isolate, mutex, state)) \{}
\DoxyCodeLine{911     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{912   \}}
\DoxyCodeLine{913 }
\DoxyCodeLine{914   \textcolor{comment}{// At this point the lock is considered contended, create a new async waiter}}
\DoxyCodeLine{915   \textcolor{comment}{// node in the C++ heap. It's lifetime is managed by the requester's}}
\DoxyCodeLine{916   \textcolor{comment}{// `async\_waiter\_queue\_nodes` list.}}
\DoxyCodeLine{917   \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{LockAsyncWaiterQueueNode}}* this\_waiter =}
\DoxyCodeLine{918       \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_aedd8acca7e7b7094e41c594ad63bd0d3}{LockAsyncWaiterQueueNode::NewAsyncWaiterStoredInIsolate}}(}
\DoxyCodeLine{919           isolate, mutex, internal\_locked\_promise, unlocked\_promise);}
\DoxyCodeLine{920   \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}{MaybeEnqueueNode}}(isolate, mutex, state, this\_waiter)) \{}
\DoxyCodeLine{921     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{922   \}}
\DoxyCodeLine{923 }
\DoxyCodeLine{924   \textcolor{keywordflow}{if} (timeout) \{}
\DoxyCodeLine{925     \textcolor{comment}{// Start a timer to run the `AsyncLockTimeoutTask` after the timeout.}}
\DoxyCodeLine{926     \mbox{\hyperlink{namespacecppgc_a3c2b2bee060b35e6507a2d25c5e5abc7}{TaskRunner}}* taks\_runner = this\_waiter-\/>task\_runner();}
\DoxyCodeLine{927     \textcolor{keyword}{auto} task = std::make\_unique<AsyncLockTimeoutTask>(}
\DoxyCodeLine{928         isolate-\/>cancelable\_task\_manager(), this\_waiter);}
\DoxyCodeLine{929     this\_waiter-\/>timeout\_task\_id\_ = task-\/>id();}
\DoxyCodeLine{930     taks\_runner-\/>PostNonNestableDelayedTask(std::move(task),}
\DoxyCodeLine{931                                             timeout-\/>InSecondsF());}
\DoxyCodeLine{932   \}}
\DoxyCodeLine{933   *waiter\_node = this\_waiter;}
\DoxyCodeLine{934   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{935 \}}

\end{DoxyCode}


References Backoff\+Try\+Lock(), v8\+::internal\+::\+Isolate\+::cancelable\+\_\+task\+\_\+manager(), Maybe\+Enqueue\+Node(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+New\+Async\+Waiter\+Stored\+In\+Isolate(), v8\+::\+Task\+Runner\+::\+Post\+Non\+Nestable\+Delayed\+Task(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::task\+\_\+runner(), and v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::timeout\+\_\+task\+\_\+id\+\_\+.



Referenced by Lock\+Async().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ab7e2476ac1ba817339cc2ce7211cb401_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a11ead00d22c8ccbb4ff02c13c7f86cdd}\label{classv8_1_1internal_1_1JSAtomicsMutex_a11ead00d22c8ccbb4ff02c13c7f86cdd}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockAsyncWrapperForWait@{LockAsyncWrapperForWait}}
\index{LockAsyncWrapperForWait@{LockAsyncWrapperForWait}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockAsyncWrapperForWait()}{LockAsyncWrapperForWait()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Async\+Wrapper\+For\+Wait (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 892 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{893                                                             \{}
\DoxyCodeLine{894   Handle<JSPromise> internal\_locked\_promise =}
\DoxyCodeLine{895       requester-\/>factory()-\/>NewJSPromise();}
\DoxyCodeLine{896   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_acfeaf67200a748d8951863d66d2317e6}{AsyncWaiterNodeType}}* waiter\_node = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{897   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a}{LockAsync}}(requester, mutex, internal\_locked\_promise, \{\}, \&waiter\_node);}
\DoxyCodeLine{898   \textcolor{keywordflow}{return} internal\_locked\_promise;}
\DoxyCodeLine{899 \}}

\end{DoxyCode}


References v8\+::internal\+::\+Isolate\+::factory(), Lock\+Async(), and v8\+::internal\+::\+Factory\+::\+New\+JSPromise().



Referenced by v8\+::internal\+::\+BUILTIN().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a11ead00d22c8ccbb4ff02c13c7f86cdd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a11ead00d22c8ccbb4ff02c13c7f86cdd_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8}\label{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockImpl@{LockImpl}}
\index{LockImpl@{LockImpl}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockImpl()}{LockImpl()}}
{\footnotesize\ttfamily template$<$typename Lock\+Slow\+Path\+Wrapper , typename $>$ \\
\mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Impl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout,  }\item[{Lock\+Slow\+Path\+Wrapper}]{slow\+\_\+path\+\_\+wrapper }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 154 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{157                                                                      \{}
\DoxyCodeLine{158   \mbox{\hyperlink{namespacev8_1_1internal_af2248a427f8ff8f81e68a2a87758e145}{DisallowGarbageCollection}} \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02json-stringifier_8cc_03_a63d8eefb47468aa3f816fbe26a59466a}{no\_gc}};}
\DoxyCodeLine{159   \textcolor{comment}{// First try to lock an uncontended mutex, which should be the common case. If}}
\DoxyCodeLine{160   \textcolor{comment}{// this fails, then go to the slow path to possibly put the current thread to}}
\DoxyCodeLine{161   \textcolor{comment}{// sleep.}}
\DoxyCodeLine{162   \textcolor{comment}{//}}
\DoxyCodeLine{163   \textcolor{comment}{// The fast path is done using a weak CAS which may fail spuriously on}}
\DoxyCodeLine{164   \textcolor{comment}{// architectures with load-\/link/store-\/conditional instructions.}}
\DoxyCodeLine{165   std::atomic<StateT>* state = mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{166   StateT expected = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}};}
\DoxyCodeLine{167   \textcolor{keywordtype}{bool} locked;}
\DoxyCodeLine{168   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a4f489f1b838163ab33f251c9e470d938}{V8\_LIKELY}}(state-\/>compare\_exchange\_weak(expected, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}{kLockedUncontended}},}
\DoxyCodeLine{169                                              std::memory\_order\_acquire,}
\DoxyCodeLine{170                                              std::memory\_order\_relaxed))) \{}
\DoxyCodeLine{171     locked = \textcolor{keyword}{true};}
\DoxyCodeLine{172   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{173     locked = slow\_path\_wrapper(state);}
\DoxyCodeLine{174   \}}
\DoxyCodeLine{175   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a4f489f1b838163ab33f251c9e470d938}{V8\_LIKELY}}(locked)) \{}
\DoxyCodeLine{176     mutex-\/>SetCurrentThreadAsOwner();}
\DoxyCodeLine{177   \}}
\DoxyCodeLine{178   \textcolor{keywordflow}{return} locked;}
\DoxyCodeLine{179 \}}

\end{DoxyCode}


References k\+Locked\+Uncontended, k\+Unlocked\+Uncontended, v8\+::internal\+::anonymous\+\_\+namespace\{json-\/stringifier.\+cc\}\+::no\+\_\+gc, and V8\+\_\+\+LIKELY.



Referenced by Lock(), and Lock\+Async().

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a7c30bc0f07f0f6b70f597c469839d2c8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a7ab74296e2ded7c17f1719d198e8f144}\label{classv8_1_1internal_1_1JSAtomicsMutex_a7ab74296e2ded7c17f1719d198e8f144}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockJSMutexOrDequeueTimedOutWaiter@{LockJSMutexOrDequeueTimedOutWaiter}}
\index{LockJSMutexOrDequeueTimedOutWaiter@{LockJSMutexOrDequeueTimedOutWaiter}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockJSMutexOrDequeueTimedOutWaiter()}{LockJSMutexOrDequeueTimedOutWaiter()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+JSMutex\+Or\+Dequeue\+Timed\+Out\+Waiter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$}]{timed\+\_\+out\+\_\+waiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 669 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{671                                        \{}
\DoxyCodeLine{672   \textcolor{comment}{// First acquire the queue lock, which is itself a spinlock.}}
\DoxyCodeLine{673   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{674   \textcolor{comment}{// There are no waiters, but the js mutex lock may be held by another thread.}}
\DoxyCodeLine{675   \textcolor{keywordflow}{if} (!HasWaitersField::decode(current\_state)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{676 }
\DoxyCodeLine{677   \textcolor{comment}{// The details of updating the state in this function are too complicated}}
\DoxyCodeLine{678   \textcolor{comment}{// for the waiter queue lock guard to manage, so handle the state manually.}}
\DoxyCodeLine{679   \textcolor{keywordflow}{while} (!TryLockWaiterQueueExplicit(state, current\_state)) \{}
\DoxyCodeLine{680     \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{681   \}}
\DoxyCodeLine{682 }
\DoxyCodeLine{683   WaiterQueueNode* waiter\_head = DestructivelyGetWaiterQueueHead(requester);}
\DoxyCodeLine{684 }
\DoxyCodeLine{685   \textcolor{keywordflow}{if} (waiter\_head == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{686     \textcolor{comment}{// The queue is empty but the js mutex lock may be held by another thread,}}
\DoxyCodeLine{687     \textcolor{comment}{// release the waiter queue bit without changing the "{}is locked"{} bit.}}
\DoxyCodeLine{688     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(!HasWaitersField::decode(current\_state));}
\DoxyCodeLine{689     SetWaiterQueueStateOnly(state, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}});}
\DoxyCodeLine{690     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{691   \}}
\DoxyCodeLine{692 }
\DoxyCodeLine{693   WaiterQueueNode* dequeued\_node = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_ae672d68e7aa4d9a4e071c204a98ce022}{WaiterQueueNode::DequeueMatching}}(}
\DoxyCodeLine{694       \&waiter\_head,}
\DoxyCodeLine{695       [\&](WaiterQueueNode* node) \{ \textcolor{keywordflow}{return} node == timed\_out\_waiter; \});}
\DoxyCodeLine{696 }
\DoxyCodeLine{697   \textcolor{comment}{// Release the queue lock and install the new waiter queue head.}}
\DoxyCodeLine{698   \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(state-\/>load(),}
\DoxyCodeLine{699             IsWaiterQueueLockedField::update(current\_state, \textcolor{keyword}{true}));}
\DoxyCodeLine{700   StateT new\_state = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}};}
\DoxyCodeLine{701   new\_state = SetWaiterQueueHead(requester, waiter\_head, new\_state);}
\DoxyCodeLine{702 }
\DoxyCodeLine{703   \textcolor{keywordflow}{if} (!dequeued\_node) \{}
\DoxyCodeLine{704     \textcolor{comment}{// The timed out waiter was not in the queue, so it must have been dequeued}}
\DoxyCodeLine{705     \textcolor{comment}{// and notified between the time this thread woke up and the time it}}
\DoxyCodeLine{706     \textcolor{comment}{// acquired the queue lock, so there is a risk that the next queue head is}}
\DoxyCodeLine{707     \textcolor{comment}{// never notified. Try to take the js mutex lock here, if we succeed, the}}
\DoxyCodeLine{708     \textcolor{comment}{// next node will be notified by this thread, otherwise, it will be notified}}
\DoxyCodeLine{709     \textcolor{comment}{// by the thread holding the lock now.}}
\DoxyCodeLine{710 }
\DoxyCodeLine{711     \textcolor{comment}{// Since we use strong CAS below, we know that the js mutex lock will be}}
\DoxyCodeLine{712     \textcolor{comment}{// held by either this thread or another thread that can't go through the}}
\DoxyCodeLine{713     \textcolor{comment}{// unlock fast path because this thread is holding the waiter queue lock.}}
\DoxyCodeLine{714     \textcolor{comment}{// Hence, it is safe to always set the "{}is locked"{} bit in new\_state.}}
\DoxyCodeLine{715     new\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(new\_state, \textcolor{keyword}{true});}
\DoxyCodeLine{716     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(!IsWaiterQueueLockedField::decode(new\_state));}
\DoxyCodeLine{717     current\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(current\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{718     \textcolor{keywordflow}{if} (state-\/>compare\_exchange\_strong(current\_state, new\_state,}
\DoxyCodeLine{719                                        std::memory\_order\_acq\_rel,}
\DoxyCodeLine{720                                        std::memory\_order\_relaxed)) \{}
\DoxyCodeLine{721       \textcolor{comment}{// The CAS atomically released the waiter queue lock and acquired the js}}
\DoxyCodeLine{722       \textcolor{comment}{// mutex lock.}}
\DoxyCodeLine{723       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{724     \}}
\DoxyCodeLine{725 }
\DoxyCodeLine{726     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(\mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(state-\/>load()));}
\DoxyCodeLine{727     state-\/>store(new\_state, std::memory\_order\_release);}
\DoxyCodeLine{728     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{729   \}}
\DoxyCodeLine{730 }
\DoxyCodeLine{731   SetWaiterQueueStateOnly(state, new\_state);}
\DoxyCodeLine{732   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{733 \}}

\end{DoxyCode}


References v8\+::internal\+::\+DCHECK(), DCHECK\+\_\+\+EQ, v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::decode(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue\+Matching(), k\+Unlocked\+Uncontended, v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::update(), and YIELD\+\_\+\+PROCESSOR.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a7ab74296e2ded7c17f1719d198e8f144_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e}\label{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockOrEnqueueAsyncNode@{LockOrEnqueueAsyncNode}}
\index{LockOrEnqueueAsyncNode@{LockOrEnqueueAsyncNode}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockOrEnqueueAsyncNode()}{LockOrEnqueueAsyncNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Or\+Enqueue\+Async\+Node (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{isolate,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{Lock\+Async\+Waiter\+Queue\+Node}} $\ast$}]{node }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 938 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{940                                                                               \{}
\DoxyCodeLine{941   std::atomic<StateT>* state = mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{942   \textcolor{comment}{// Spin for a little bit to try to acquire the lock, so as to be fast under}}
\DoxyCodeLine{943   \textcolor{comment}{// microcontention.}}
\DoxyCodeLine{944   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}{BackoffTryLock}}(isolate, mutex, state)) \{}
\DoxyCodeLine{945     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{946   \}}
\DoxyCodeLine{947 }
\DoxyCodeLine{948   \textcolor{keywordflow}{return} !\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}{MaybeEnqueueNode}}(isolate, mutex, state, waiter);}
\DoxyCodeLine{949 \}}

\end{DoxyCode}


References Backoff\+Try\+Lock(), and Maybe\+Enqueue\+Node().



Referenced by Handle\+Async\+Notify().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aa3df13a6189126776aa669bba26d256e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_ae91cc5f649b3e630c487c544613a67af}\label{classv8_1_1internal_1_1JSAtomicsMutex_ae91cc5f649b3e630c487c544613a67af}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockOrEnqueuePromise@{LockOrEnqueuePromise}}
\index{LockOrEnqueuePromise@{LockOrEnqueuePromise}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockOrEnqueuePromise()}{LockOrEnqueuePromise()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classv8_1_1internal_1_1MaybeDirectHandle}{Maybe\+Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSPromise}{JSPromise}} $>$ v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Or\+Enqueue\+Promise (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{isolate,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Object}{Object}} $>$}]{callback,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 821 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{823                                                                        \{}
\DoxyCodeLine{824   Handle<JSPromise> internal\_locked\_promise =}
\DoxyCodeLine{825       requester-\/>factory()-\/>NewJSPromise();}
\DoxyCodeLine{826   DirectHandle<JSReceiver> waiting\_for\_callback\_promise;}
\DoxyCodeLine{827   \mbox{\hyperlink{execution_2isolate_8h_a45bb81ab232e9f2663545ec92dc0b950}{ASSIGN\_RETURN\_ON\_EXCEPTION}}(}
\DoxyCodeLine{828       requester, waiting\_for\_callback\_promise,}
\DoxyCodeLine{829       \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02js-atomics-synchronization_8cc_03_a5e71d6d2dee15c738e0fc3ce715c12f4}{PerformPromiseThen}}(requester, internal\_locked\_promise, callback));}
\DoxyCodeLine{830   Handle<JSPromise> unlocked\_promise = requester-\/>factory()-\/>NewJSPromise();}
\DoxyCodeLine{831   \textcolor{comment}{// Set the async unlock handlers here so we can throw without any additional}}
\DoxyCodeLine{832   \textcolor{comment}{// cleanup if the inner `promise\_then` call fails. Keep a reference to}}
\DoxyCodeLine{833   \textcolor{comment}{// the handlers' synthetic context so we can store the waiter node in it once}}
\DoxyCodeLine{834   \textcolor{comment}{// the node is created.}}
\DoxyCodeLine{835   DirectHandle<Context> handlers\_context;}
\DoxyCodeLine{836   \mbox{\hyperlink{execution_2isolate_8h_a45bb81ab232e9f2663545ec92dc0b950}{ASSIGN\_RETURN\_ON\_EXCEPTION}}(}
\DoxyCodeLine{837       requester, handlers\_context,}
\DoxyCodeLine{838       \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02js-atomics-synchronization_8cc_03_a1683c8a2afdec8e3fceaf49fb74deb7e}{SetAsyncUnlockHandlers}}(requester, mutex, waiting\_for\_callback\_promise,}
\DoxyCodeLine{839                              unlocked\_promise));}
\DoxyCodeLine{840   \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{LockAsyncWaiterQueueNode}}* waiter\_node = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{841   \textcolor{keywordtype}{bool} locked = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aae02b4dde618ba45d09c5516e0518a2a}{LockAsync}}(requester, mutex, internal\_locked\_promise,}
\DoxyCodeLine{842                           unlocked\_promise, \&waiter\_node, timeout);}
\DoxyCodeLine{843   \textcolor{keywordflow}{if} (locked) \{}
\DoxyCodeLine{844     \textcolor{comment}{// Create an LockAsyncWaiterQueueNode to be queued in the async locked}}
\DoxyCodeLine{845     \textcolor{comment}{// waiter queue.}}
\DoxyCodeLine{846     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(!waiter\_node);}
\DoxyCodeLine{847     waiter\_node = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_aca0aa1ce679e780c25580d9d925e8cf1}{LockAsyncWaiterQueueNode::NewLockedAsyncWaiterStoredInIsolate}}(}
\DoxyCodeLine{848         requester, mutex);}
\DoxyCodeLine{849   \}}
\DoxyCodeLine{850   \textcolor{comment}{// Don't use kWaiterQueueNodeTag here as that will cause the pointer to be}}
\DoxyCodeLine{851   \textcolor{comment}{// stored in the shared external pointer table, which is not necessary since}}
\DoxyCodeLine{852   \textcolor{comment}{// this object is only visible in this thread.}}
\DoxyCodeLine{853   DirectHandle<Foreign> wrapper =}
\DoxyCodeLine{854       requester-\/>factory()-\/>NewForeign<\mbox{\hyperlink{namespacev8_1_1internal_aa5178998e7ae493acf744bc92b1fbdbca60ae2e850cf8922552f532a8a62617e9}{kWaiterQueueForeignTag}}>(}
\DoxyCodeLine{855           \textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{namespacev8_1_1internal_ab4955debfb9384e59e3d4e9fcab5b0a0}{Address}}\textcolor{keyword}{>}(waiter\_node));}
\DoxyCodeLine{856   handlers\_context-\/>SetNoCell(}
\DoxyCodeLine{857       \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a750d3d3223266c3e6b0564379ccb5a42ae64536b44b43e437a759d5033e1aaeea}{JSAtomicsMutex::kAsyncLockedWaiterAsyncContextSlot}}, *wrapper);}
\DoxyCodeLine{858   \textcolor{keywordflow}{return} unlocked\_promise;}
\DoxyCodeLine{859 \}}

\end{DoxyCode}


References ASSIGN\+\_\+\+RETURN\+\_\+\+ON\+\_\+\+EXCEPTION, v8\+::internal\+::\+DCHECK(), v8\+::internal\+::\+Isolate\+::factory(), k\+Async\+Locked\+Waiter\+Async\+Context\+Slot, v8\+::internal\+::k\+Waiter\+Queue\+Foreign\+Tag, Lock\+Async(), v8\+::internal\+::\+Factory\+::\+New\+Foreign(), v8\+::internal\+::\+Factory\+::\+New\+JSPromise(), v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+New\+Locked\+Async\+Waiter\+Stored\+In\+Isolate(), v8\+::internal\+::anonymous\+\_\+namespace\{js-\/atomics-\/synchronization.\+cc\}\+::\+Perform\+Promise\+Then(), and v8\+::internal\+::anonymous\+\_\+namespace\{js-\/atomics-\/synchronization.\+cc\}\+::\+Set\+Async\+Unlock\+Handlers().



Referenced by v8\+::internal\+::\+BUILTIN().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ae91cc5f649b3e630c487c544613a67af_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ae91cc5f649b3e630c487c544613a67af_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31}\label{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockSlowPath@{LockSlowPath}}
\index{LockSlowPath@{LockSlowPath}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockSlowPath()}{LockSlowPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Slow\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{std\+::optional$<$ \mbox{\hyperlink{classv8_1_1base_1_1TimeDelta}{base\+::\+Time\+Delta}} $>$}]{timeout }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 736 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{739                                                                       \{}
\DoxyCodeLine{740   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{741     \textcolor{comment}{// Spin for a little bit to try to acquire the lock, so as to be fast under}}
\DoxyCodeLine{742     \textcolor{comment}{// microcontention.}}
\DoxyCodeLine{743     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_afb36fc0276082e7d8e41e3910e44afcd}{BackoffTryLock}}(requester, mutex, state)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{744 }
\DoxyCodeLine{745     \textcolor{comment}{// At this point the lock is considered contended, so try to go to sleep and}}
\DoxyCodeLine{746     \textcolor{comment}{// put the requester thread on the waiter queue.}}
\DoxyCodeLine{747 }
\DoxyCodeLine{748     \textcolor{comment}{// Allocate a waiter queue node on-\/stack, since this thread is going to}}
\DoxyCodeLine{749     \textcolor{comment}{// sleep and will be blocked anyway.}}
\DoxyCodeLine{750     SyncWaiterQueueNode this\_waiter(requester);}
\DoxyCodeLine{751     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}{MaybeEnqueueNode}}(requester, mutex, state, \&this\_waiter)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{752 }
\DoxyCodeLine{753     \textcolor{keywordtype}{bool} rv;}
\DoxyCodeLine{754     \textcolor{comment}{// Wait for another thread to release the lock and wake us up.}}
\DoxyCodeLine{755     \textcolor{keywordflow}{if} (timeout) \{}
\DoxyCodeLine{756       rv = this\_waiter.WaitFor(*timeout);}
\DoxyCodeLine{757       \textcolor{comment}{// Reload the state pointer after wake up in case of shared GC while}}
\DoxyCodeLine{758       \textcolor{comment}{// blocked.}}
\DoxyCodeLine{759       state = mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{760       \textcolor{keywordflow}{if} (!rv) \{}
\DoxyCodeLine{761         \textcolor{comment}{// If timed out, remove ourself from the waiter list, which is usually}}
\DoxyCodeLine{762         \textcolor{comment}{// done by the thread performing the notifying.}}
\DoxyCodeLine{763         rv = mutex-\/>LockJSMutexOrDequeueTimedOutWaiter(requester, state,}
\DoxyCodeLine{764                                                        \&this\_waiter);}
\DoxyCodeLine{765         \textcolor{keywordflow}{return} rv;}
\DoxyCodeLine{766       \}}
\DoxyCodeLine{767     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{768       this\_waiter.Wait();}
\DoxyCodeLine{769       \textcolor{comment}{// Reload the state pointer after wake up in case of shared GC while}}
\DoxyCodeLine{770       \textcolor{comment}{// blocked.}}
\DoxyCodeLine{771       state = mutex-\/>AtomicStatePtr();}
\DoxyCodeLine{772     \}}
\DoxyCodeLine{773 }
\DoxyCodeLine{774     \textcolor{comment}{// After wake up we try to acquire the lock again by spinning, as the}}
\DoxyCodeLine{775     \textcolor{comment}{// contention at the point of going to sleep should not be correlated with}}
\DoxyCodeLine{776     \textcolor{comment}{// contention at the point of waking up.}}
\DoxyCodeLine{777   \}}
\DoxyCodeLine{778 \}}

\end{DoxyCode}


References Backoff\+Try\+Lock(), Maybe\+Enqueue\+Node(), v8\+::internal\+::detail\+::\+Sync\+Waiter\+Queue\+Node\+::\+Wait(), and v8\+::internal\+::detail\+::\+Sync\+Waiter\+Queue\+Node\+::\+Wait\+For().



Referenced by Lock().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_ac8bf7d94723c5c295222dd8d4a166b31_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c}\label{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!LockWaiterQueueOrJSMutex@{LockWaiterQueueOrJSMutex}}
\index{LockWaiterQueueOrJSMutex@{LockWaiterQueueOrJSMutex}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{LockWaiterQueueOrJSMutex()}{LockWaiterQueueOrJSMutex()}}
{\footnotesize\ttfamily std\+::optional$<$ \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueLockGuard}{Waiter\+Queue\+Lock\+Guard}} $>$ v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Lock\+Waiter\+Queue\+Or\+JSMutex (\begin{DoxyParamCaption}\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{StateT \&}]{current\+\_\+state }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 655 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{656                                                      \{}
\DoxyCodeLine{657   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{658     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(current\_state) \&\&}
\DoxyCodeLine{659         TryLockWaiterQueueExplicit(state, current\_state)) \{}
\DoxyCodeLine{660       \textcolor{keywordflow}{return} \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueLockGuard_a5b8a57870347f8f3385aad91b182f63c}{WaiterQueueLockGuard::NewAlreadyLockedWaiterQueueLockGuard}}(state);}
\DoxyCodeLine{661     \}}
\DoxyCodeLine{662     \textcolor{comment}{// Also check for the lock having been released by another thread during}}
\DoxyCodeLine{663     \textcolor{comment}{// attempts to acquire the queue lock.}}
\DoxyCodeLine{664     \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7}{TryLockExplicit}}(state, current\_state)) \textcolor{keywordflow}{return} std::nullopt;}
\DoxyCodeLine{665     \mbox{\hyperlink{yield-processor_8h_a753c4dcdfb9d3cd7e9228ecc76bee114}{YIELD\_PROCESSOR}};}
\DoxyCodeLine{666   \}}
\DoxyCodeLine{667 \}}

\end{DoxyCode}


References v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::decode(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Lock\+Guard\+::\+New\+Already\+Locked\+Waiter\+Queue\+Lock\+Guard(), Try\+Lock\+Explicit(), and YIELD\+\_\+\+PROCESSOR.



Referenced by Maybe\+Enqueue\+Node().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}\label{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!MaybeEnqueueNode@{MaybeEnqueueNode}}
\index{MaybeEnqueueNode@{MaybeEnqueueNode}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{MaybeEnqueueNode()}{MaybeEnqueueNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Maybe\+Enqueue\+Node (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode}{Waiter\+Queue\+Node}} $\ast$}]{this\+\_\+waiter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 621 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{624                                                                     \{}
\DoxyCodeLine{625   \mbox{\hyperlink{src_2base_2logging_8h_a7b9f9517fedacc2a1a56c2bbb9d03688}{DCHECK\_NOT\_NULL}}(this\_waiter);}
\DoxyCodeLine{626   \textcolor{comment}{// Try to acquire the queue lock, which is itself a spinlock.}}
\DoxyCodeLine{627   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{628   std::optional<WaiterQueueLockGuard> waiter\_queue\_lock\_guard =}
\DoxyCodeLine{629       \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a9366032c352dd4ea1aacba86b387ff3c}{LockWaiterQueueOrJSMutex}}(state, current\_state);}
\DoxyCodeLine{630   \textcolor{keywordflow}{if} (!waiter\_queue\_lock\_guard.has\_value()) \{}
\DoxyCodeLine{631     \textcolor{comment}{// There is no waiter queue lock guard, so the lock was acquired.}}
\DoxyCodeLine{632     \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(\mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(state-\/>load()));}
\DoxyCodeLine{633     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{634   \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636   \textcolor{comment}{// With the queue lock held, enqueue the requester onto the waiter queue.}}
\DoxyCodeLine{637   WaiterQueueNode* waiter\_head =}
\DoxyCodeLine{638       mutex-\/>DestructivelyGetWaiterQueueHead(requester);}
\DoxyCodeLine{639   \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_a639d7e56545b8e47357d1564989d070d}{WaiterQueueNode::Enqueue}}(\&waiter\_head, this\_waiter);}
\DoxyCodeLine{640 }
\DoxyCodeLine{641   \textcolor{comment}{// Enqueue a new waiter queue head and release the queue lock.}}
\DoxyCodeLine{642   \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(state-\/>load(),}
\DoxyCodeLine{643             IsWaiterQueueLockedField::update(current\_state, \textcolor{keyword}{true}));}
\DoxyCodeLine{644   StateT new\_state =}
\DoxyCodeLine{645       mutex-\/>SetWaiterQueueHead(requester, waiter\_head, current\_state);}
\DoxyCodeLine{646   \textcolor{comment}{// The lock is held, just not by us, so don't set the current thread id as}}
\DoxyCodeLine{647   \textcolor{comment}{// the owner.}}
\DoxyCodeLine{648   \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(\mbox{\hyperlink{classv8_1_1base_1_1BitField_a554df4b9ae5f0dc36b4d092bfc2e004b}{IsLockedField::decode}}(current\_state));}
\DoxyCodeLine{649   new\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(new\_state, \textcolor{keyword}{true});}
\DoxyCodeLine{650   waiter\_queue\_lock\_guard-\/>set\_new\_state(new\_state);}
\DoxyCodeLine{651   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{652 \}}

\end{DoxyCode}


References v8\+::internal\+::\+DCHECK(), DCHECK\+\_\+\+EQ, DCHECK\+\_\+\+NOT\+\_\+\+NULL, v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::decode(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Enqueue(), Lock\+Waiter\+Queue\+Or\+JSMutex(), and v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::update().



Referenced by Lock\+Async\+Slow\+Path(), Lock\+Or\+Enqueue\+Async\+Node(), and Lock\+Slow\+Path().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a4616a757face97266410b7318b372f19_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a6cd32ae00cc01ca7437d432cab96b10c}\label{classv8_1_1internal_1_1JSAtomicsMutex_a6cd32ae00cc01ca7437d432cab96b10c}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!MutexTryLock@{MutexTryLock}}
\index{MutexTryLock@{MutexTryLock}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{MutexTryLock()}{MutexTryLock()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{src_2base_2macros_8h_ab08e353943a53678ac6baafc678f2d81}{V8\+\_\+\+EXPORT\+\_\+\+PRIVATE}} \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Mutex\+Try\+Lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex}{JSAtomics\+Mutex}} $>$}]{mutex,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}

\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf}\label{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!SetCurrentThreadAsOwner@{SetCurrentThreadAsOwner}}
\index{SetCurrentThreadAsOwner@{SetCurrentThreadAsOwner}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{SetCurrentThreadAsOwner()}{SetCurrentThreadAsOwner()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Set\+Current\+Thread\+As\+Owner (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



Definition at line 234 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{234                                              \{}
\DoxyCodeLine{235   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}{AtomicOwnerThreadIdPtr}}()-\/>store(\mbox{\hyperlink{classv8_1_1internal_1_1ThreadId_a81c60d3524b03db2f154b7f682e7796f}{ThreadId::Current}}().ToInteger(),}
\DoxyCodeLine{236                                   std::memory\_order\_relaxed);}
\DoxyCodeLine{237 \}}

\end{DoxyCode}


References Atomic\+Owner\+Thread\+Id\+Ptr(), and v8\+::internal\+::\+Thread\+Id\+::\+Current().



Referenced by Try\+Lock().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_aaf1f431fef6b2704f0c784653b8b6ce0}\label{classv8_1_1internal_1_1JSAtomicsMutex_aaf1f431fef6b2704f0c784653b8b6ce0}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!TryLock@{TryLock}}
\index{TryLock@{TryLock}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{TryLock()}{TryLock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Try\+Lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 190 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{190                              \{}
\DoxyCodeLine{191   \mbox{\hyperlink{namespacev8_1_1internal_af2248a427f8ff8f81e68a2a87758e145}{DisallowGarbageCollection}} \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02json-stringifier_8cc_03_a63d8eefb47468aa3f816fbe26a59466a}{no\_gc}};}
\DoxyCodeLine{192   StateT expected = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}};}
\DoxyCodeLine{193   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a4f489f1b838163ab33f251c9e470d938}{V8\_LIKELY}}(AtomicStatePtr()-\/>compare\_exchange\_strong(}
\DoxyCodeLine{194           expected, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}{kLockedUncontended}}, std::memory\_order\_acquire,}
\DoxyCodeLine{195           std::memory\_order\_relaxed))) \{}
\DoxyCodeLine{196     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a0e568254dbb2720ce375e668f60d8bbf}{SetCurrentThreadAsOwner}}();}
\DoxyCodeLine{197     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{198   \}}
\DoxyCodeLine{199   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{200 \}}

\end{DoxyCode}


References k\+Locked\+Uncontended, k\+Unlocked\+Uncontended, v8\+::internal\+::anonymous\+\_\+namespace\{json-\/stringifier.\+cc\}\+::no\+\_\+gc, Set\+Current\+Thread\+As\+Owner(), and V8\+\_\+\+LIKELY.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aaf1f431fef6b2704f0c784653b8b6ce0_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7}\label{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!TryLockExplicit@{TryLockExplicit}}
\index{TryLockExplicit@{TryLockExplicit}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{TryLockExplicit()}{TryLockExplicit()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacev8_1_1internal_a4e2118a7c0d730210e0cb87b511cba70}{bool}} v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Try\+Lock\+Explicit (\begin{DoxyParamCaption}\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state,  }\item[{StateT \&}]{expected }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}



Definition at line 589 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{590                                                        \{}
\DoxyCodeLine{591   \textcolor{comment}{// Try to lock a possibly contended mutex.}}
\DoxyCodeLine{592   expected = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(expected, \textcolor{keyword}{false});}
\DoxyCodeLine{593   \textcolor{keywordflow}{return} state-\/>compare\_exchange\_weak(}
\DoxyCodeLine{594       expected, \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(expected, \textcolor{keyword}{true}),}
\DoxyCodeLine{595       std::memory\_order\_acquire, std::memory\_order\_relaxed);}
\DoxyCodeLine{596 \}}

\end{DoxyCode}


References v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::update().



Referenced by Backoff\+Try\+Lock(), and Lock\+Waiter\+Queue\+Or\+JSMutex().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a3abda1880d67a5c4cdafd333ee309ee7_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673}\label{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!Unlock@{Unlock}}
\index{Unlock@{Unlock}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{Unlock()}{Unlock()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Unlock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 202 of file js-\/atomics-\/synchronization-\/inl.\+h.


\begin{DoxyCode}{0}
\DoxyCodeLine{202                                               \{}
\DoxyCodeLine{203   \mbox{\hyperlink{namespacev8_1_1internal_af2248a427f8ff8f81e68a2a87758e145}{DisallowGarbageCollection}} \mbox{\hyperlink{namespacev8_1_1internal_1_1anonymous__namespace_02json-stringifier_8cc_03_a63d8eefb47468aa3f816fbe26a59466a}{no\_gc}};}
\DoxyCodeLine{204   \textcolor{comment}{// First try to unlock an uncontended mutex, which should be the common}}
\DoxyCodeLine{205   \textcolor{comment}{// case. If this fails, then go to the slow path to wake a waiting thread.}}
\DoxyCodeLine{206   \textcolor{comment}{//}}
\DoxyCodeLine{207   \textcolor{comment}{// In contrast to Lock, the fast path is done using a strong CAS which does}}
\DoxyCodeLine{208   \textcolor{comment}{// not fail spuriously. This simplifies the slow path by guaranteeing that}}
\DoxyCodeLine{209   \textcolor{comment}{// there is at least one waiter to be notified.}}
\DoxyCodeLine{210   \mbox{\hyperlink{namespacev8_1_1internal_aa6b3743bd5d773c552654f2a6c3efa4a}{DCHECK}}(\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e}{IsCurrentThreadOwner}}());}
\DoxyCodeLine{211   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a5eef16f892811b86a20bcbf5d2a9d40d}{ClearOwnerThread}}();}
\DoxyCodeLine{212   std::atomic<StateT>* state = AtomicStatePtr();}
\DoxyCodeLine{213   StateT expected = \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}{kLockedUncontended}};}
\DoxyCodeLine{214   \textcolor{keywordflow}{if} (\mbox{\hyperlink{v8config_8h_a4f489f1b838163ab33f251c9e470d938}{V8\_LIKELY}}(state-\/>compare\_exchange\_strong(expected, \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}{kUnlockedUncontended}},}
\DoxyCodeLine{215                                                std::memory\_order\_release,}
\DoxyCodeLine{216                                                std::memory\_order\_relaxed))) \{}
\DoxyCodeLine{217     \textcolor{keywordflow}{return};}
\DoxyCodeLine{218   \}}
\DoxyCodeLine{219   \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674}{UnlockSlowPath}}(requester, state);}
\DoxyCodeLine{220 \}}

\end{DoxyCode}


References Clear\+Owner\+Thread(), v8\+::internal\+::\+DCHECK(), Is\+Current\+Thread\+Owner(), k\+Locked\+Uncontended, k\+Unlocked\+Uncontended, v8\+::internal\+::anonymous\+\_\+namespace\{json-\/stringifier.\+cc\}\+::no\+\_\+gc, Unlock\+Slow\+Path(), and V8\+\_\+\+LIKELY.



Referenced by Unlock\+Async\+Locked\+Mutex().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a2f85be184435df82fb19287958d56021}\label{classv8_1_1internal_1_1JSAtomicsMutex_a2f85be184435df82fb19287958d56021}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!UnlockAsyncLockedMutex@{UnlockAsyncLockedMutex}}
\index{UnlockAsyncLockedMutex@{UnlockAsyncLockedMutex}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{UnlockAsyncLockedMutex()}{UnlockAsyncLockedMutex()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Unlock\+Async\+Locked\+Mutex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{\mbox{\hyperlink{classv8_1_1internal_1_1DirectHandle}{Direct\+Handle}}$<$ \mbox{\hyperlink{classv8_1_1internal_1_1Foreign}{Foreign}} $>$}]{async\+\_\+locked\+\_\+waiter\+\_\+wrapper }\end{DoxyParamCaption})}



Definition at line 951 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{952                                                                            \{}
\DoxyCodeLine{953   \mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{LockAsyncWaiterQueueNode}}* waiter\_node =}
\DoxyCodeLine{954       \textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{namespacev8_1_1internal_a8f4ee6413da93bb138aee3c7c8316fe6}{LockAsyncWaiterQueueNode}}*\textcolor{keyword}{>}(}
\DoxyCodeLine{955           async\_locked\_waiter\_wrapper-\/>foreign\_address<\mbox{\hyperlink{namespacev8_1_1internal_aa5178998e7ae493acf744bc92b1fbdbca60ae2e850cf8922552f532a8a62617e9}{kWaiterQueueForeignTag}}>(}
\DoxyCodeLine{956               IsolateForSandbox(requester)));}
\DoxyCodeLine{957   \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1AsyncWaiterQueueNode_a52115608b23a4b7d2d5e8fd0ffffa1d0}{LockAsyncWaiterQueueNode::RemoveFromAsyncWaiterQueueList}}(waiter\_node);}
\DoxyCodeLine{958   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_addaae4dc87fff8c1b4877fd9a888956e}{IsCurrentThreadOwner}}()) \{}
\DoxyCodeLine{959     \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_aaa58ad7796019bb3edcfa72926a01673}{Unlock}}(requester);}
\DoxyCodeLine{960     \textcolor{keywordflow}{return};}
\DoxyCodeLine{961   \}}
\DoxyCodeLine{962   \textcolor{comment}{// If this is reached, the lock was already released by this thread.}}
\DoxyCodeLine{963   \textcolor{comment}{// This can happen if waitAsync is called without awaiting or due to}}
\DoxyCodeLine{964   \textcolor{comment}{// promise prototype tampering. Setting Promise.prototype.then to a}}
\DoxyCodeLine{965   \textcolor{comment}{// non callable will cause the `waiting\_for\_callback\_promise` (defined in}}
\DoxyCodeLine{966   \textcolor{comment}{// LockOrEnqueuePromise) reactions to be called even if the async callback}}
\DoxyCodeLine{967   \textcolor{comment}{// is not resolved; as a consequence, the following code will try to unlock}}
\DoxyCodeLine{968   \textcolor{comment}{// the mutex twice:}}
\DoxyCodeLine{969   \textcolor{comment}{//}}
\DoxyCodeLine{970   \textcolor{comment}{// let mutex = new Atomics.Mutex();}}
\DoxyCodeLine{971   \textcolor{comment}{// let cv = new Atomics.Condition();}}
\DoxyCodeLine{972   \textcolor{comment}{// Promise.prototype.then = undefined;}}
\DoxyCodeLine{973   \textcolor{comment}{// Atomics.Mutex.lockAsync(mutex, async function() \{}}
\DoxyCodeLine{974   \textcolor{comment}{//   await Atomics.Condition.waitAsync(cv, mutex);}}
\DoxyCodeLine{975   \textcolor{comment}{// \}}}
\DoxyCodeLine{976 \}}

\end{DoxyCode}


References Is\+Current\+Thread\+Owner(), v8\+::internal\+::k\+Waiter\+Queue\+Foreign\+Tag, v8\+::internal\+::detail\+::\+Async\+Waiter\+Queue\+Node$<$ T $>$\+::\+Remove\+From\+Async\+Waiter\+Queue\+List(), and Unlock().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a2f85be184435df82fb19287958d56021_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674}\label{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!UnlockSlowPath@{UnlockSlowPath}}
\index{UnlockSlowPath@{UnlockSlowPath}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{UnlockSlowPath()}{UnlockSlowPath()}}
{\footnotesize\ttfamily void v8\+::internal\+::\+JSAtomics\+Mutex\+::\+Unlock\+Slow\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classv8_1_1internal_1_1Isolate}{Isolate}} $\ast$}]{requester,  }\item[{std\+::atomic$<$ StateT $>$ $\ast$}]{state }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 780 of file js-\/atomics-\/synchronization.\+cc.


\begin{DoxyCode}{0}
\DoxyCodeLine{781                                                               \{}
\DoxyCodeLine{782   \textcolor{comment}{// The fast path unconditionally cleared the owner thread.}}
\DoxyCodeLine{783   \mbox{\hyperlink{src_2base_2logging_8h_af9c313d74155f7f201955a939e24c71f}{DCHECK\_EQ}}(\mbox{\hyperlink{classv8_1_1internal_1_1ThreadId_ade3e1a41d03f0f9f593c7d35c4cafa6c}{ThreadId::Invalid}}().ToInteger(),}
\DoxyCodeLine{784             \mbox{\hyperlink{classv8_1_1internal_1_1JSAtomicsMutex_ab2f7375f951c118766461226411be1ab}{AtomicOwnerThreadIdPtr}}()-\/>load(std::memory\_order\_relaxed));}
\DoxyCodeLine{785 }
\DoxyCodeLine{786   \textcolor{comment}{// To wake a sleeping thread, first acquire the queue lock, which is itself}}
\DoxyCodeLine{787   \textcolor{comment}{// a spinlock.}}
\DoxyCodeLine{788   StateT current\_state = state-\/>load(std::memory\_order\_relaxed);}
\DoxyCodeLine{789   WaiterQueueLockGuard waiter\_queue\_lock\_guard(state, current\_state);}
\DoxyCodeLine{790 }
\DoxyCodeLine{791   \textcolor{keywordflow}{if} (!HasWaitersField::decode(current\_state)) \{}
\DoxyCodeLine{792     \textcolor{comment}{// All waiters were removed while waiting for the queue lock, possibly by}}
\DoxyCodeLine{793     \textcolor{comment}{// timing out. Release both the lock and the queue lock.}}
\DoxyCodeLine{794     StateT new\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(current\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{795     waiter\_queue\_lock\_guard.set\_new\_state(new\_state);}
\DoxyCodeLine{796     \textcolor{keywordflow}{return};}
\DoxyCodeLine{797   \}}
\DoxyCodeLine{798 }
\DoxyCodeLine{799   WaiterQueueNode* waiter\_head = DestructivelyGetWaiterQueueHead(requester);}
\DoxyCodeLine{800   \mbox{\hyperlink{src_2base_2logging_8h_a7b9f9517fedacc2a1a56c2bbb9d03688}{DCHECK\_NOT\_NULL}}(waiter\_head);}
\DoxyCodeLine{801   WaiterQueueNode* old\_head = \mbox{\hyperlink{classv8_1_1internal_1_1detail_1_1WaiterQueueNode_ab5c593f10eda6b809da72dda2e1690f2}{WaiterQueueNode::Dequeue}}(\&waiter\_head);}
\DoxyCodeLine{802 }
\DoxyCodeLine{803   \textcolor{comment}{// Release both the lock and the queue lock, and install the new waiter queue}}
\DoxyCodeLine{804   \textcolor{comment}{// head.}}
\DoxyCodeLine{805   StateT new\_state = \mbox{\hyperlink{classv8_1_1base_1_1BitField_aa8d61fe165b5c0b2c869be69be02b7af}{IsLockedField::update}}(current\_state, \textcolor{keyword}{false});}
\DoxyCodeLine{806   new\_state = SetWaiterQueueHead(requester, waiter\_head, new\_state);}
\DoxyCodeLine{807   waiter\_queue\_lock\_guard.set\_new\_state(new\_state);}
\DoxyCodeLine{808 }
\DoxyCodeLine{809   old\_head-\/>Notify();}
\DoxyCodeLine{810 \}}

\end{DoxyCode}


References Atomic\+Owner\+Thread\+Id\+Ptr(), DCHECK\+\_\+\+EQ, DCHECK\+\_\+\+NOT\+\_\+\+NULL, v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Dequeue(), v8\+::internal\+::\+Thread\+Id\+::\+Invalid(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Node\+::\+Notify(), v8\+::internal\+::detail\+::\+Waiter\+Queue\+Lock\+Guard\+::set\+\_\+new\+\_\+state(), and v8\+::base\+::\+Bit\+Field$<$ T, shift, size, U $>$\+::update().



Referenced by Unlock().

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classv8_1_1internal_1_1JSAtomicsMutex_a68bd13c3c741e314efa4d6aa52242674_icgraph}
\end{center}
\end{figure}


\doxysubsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a328c093d609680cca505905c6d49901a}\label{classv8_1_1internal_1_1JSAtomicsMutex_a328c093d609680cca505905c6d49901a}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!Factory@{Factory}}
\index{Factory@{Factory}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{Factory}{Factory}}
{\footnotesize\ttfamily friend class \mbox{\hyperlink{classv8_1_1internal_1_1Factory}{Factory}}\hspace{0.3cm}{\ttfamily [friend]}}



Definition at line 296 of file js-\/atomics-\/synchronization.\+h.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}\label{classv8_1_1internal_1_1JSAtomicsMutex_a62731633096ae9f362bf7a31c1e31917}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kLockedUncontended@{kLockedUncontended}}
\index{kLockedUncontended@{kLockedUncontended}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{kLockedUncontended}{kLockedUncontended}}
{\footnotesize\ttfamily constexpr StateT v8\+::internal\+::\+JSAtomics\+Mutex\+::k\+Locked\+Uncontended = \mbox{\hyperlink{classv8_1_1base_1_1BitField_a70718344d8a4df6c20b3cf9c9b14d0d4}{Is\+Locked\+Field\+::encode}}(\mbox{\hyperlink{namespacev8_1_1internal_a7f5302a7c7fd292ffd4a5f9758bd3686}{true}})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [private]}}



Definition at line 304 of file js-\/atomics-\/synchronization.\+h.



Referenced by Lock\+Impl(), Try\+Lock(), and Unlock().

\mbox{\Hypertarget{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}\label{classv8_1_1internal_1_1JSAtomicsMutex_adad82103a513c6ae370d4410446ac458}} 
\index{v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}!kUnlockedUncontended@{kUnlockedUncontended}}
\index{kUnlockedUncontended@{kUnlockedUncontended}!v8::internal::JSAtomicsMutex@{v8::internal::JSAtomicsMutex}}
\doxysubsubsection{\texorpdfstring{kUnlockedUncontended}{kUnlockedUncontended}}
{\footnotesize\ttfamily constexpr StateT v8\+::internal\+::\+JSAtomics\+Mutex\+::k\+Unlocked\+Uncontended = k\+Empty\+State\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [private]}}



Definition at line 303 of file js-\/atomics-\/synchronization.\+h.



Referenced by Cleanup\+Matching\+Async\+Waiters(), Dequeue\+Timed\+Out\+Async\+Waiter(), Lock\+Impl(), Lock\+JSMutex\+Or\+Dequeue\+Timed\+Out\+Waiter(), v8\+::internal\+::\+Factory\+::\+New\+JSAtomics\+Mutex(), Try\+Lock(), and Unlock().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/mnt/\+V8\+Source\+Code/src/objects/\mbox{\hyperlink{js-atomics-synchronization_8h}{js-\/atomics-\/synchronization.\+h}}\item 
/mnt/\+V8\+Source\+Code/src/objects/\mbox{\hyperlink{js-atomics-synchronization-inl_8h}{js-\/atomics-\/synchronization-\/inl.\+h}}\item 
/mnt/\+V8\+Source\+Code/src/objects/\mbox{\hyperlink{js-atomics-synchronization_8cc}{js-\/atomics-\/synchronization.\+cc}}\end{DoxyCompactItemize}
